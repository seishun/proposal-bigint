<!DOCTYPE html>
<meta charset="utf-8">
<pre class="metadata">
title: BigInt
status: proposal
stage: 3
location: https://github.com/tc39/proposal-bigint
copyright: false
contributors: Daniel Ehrenberg, Brendan Eich
</pre>
<style>
emu-issue, emu-todo, emu-motivation, emu-my-example, emu-integration-plans {
    margin: 1em 0;
    padding: .5em;
    padding-left: 1em;
    display: block;
}

emu-issue:before, emu-todo:before, emu-motivation:before, emu-my-example:before, emu-integration-plans:before {
    display: block;
    padding-bottom: .5em;
    margin-left: -.5em;
}

emu-issue {
    border-left: 5px solid #ff0000;
    background: #ffdddd;
}

emu-issue:before {
    color: #770000;
    content: "ISSUE";
}

emu-motivation {
    border-left: 5px solid #aaaa00;
    background: #ffffdd;
}

emu-motivation:before {
    color: #666600;
    content: "MOTIVATION";
}

emu-todo {
    border-left: 5px solid #00aa00;
    background: #ddffdd;
}

emu-todo:before {
    color: #006600;
    content: "TODO";
}

emu-my-example {
    border-left: 5px solid #0000aa;
    background: #ddddff;
}

emu-my-example:before {
    color: #000066;
    content: "EXAMPLE";
}

emu-integration-plans {
    border-left: 5px solid #aa00aa;
    background: #ffddff;
}

emu-integration-plans:before {
    color: #660066;
    content: "INTEGRATION PLANS";
}
</style>

<emu-intro id="sec-intro">
  <h1>Introduction</h1>
<p>This proposal adds arbitrary-precision integers to ECMAScript. For motivation and a high-level introduction, see <a href="https://github.com/tc39/proposal-bigint/blob/master/README.md">the explainer document</a>.</p>

<emu-integration-plans>
  <p>I attempted to write this specification draft with an eye towards intelligibility and clarifying issues, rather than looking exactly like the final specification. In particular, the translation of the operations on the Number type into the new form are omitted, as they are identical to the previous definitions and would be expressed only as a lengthy refactoring to skip when reading this text.</p>
  <p>If you find any part of this specification unclear or confusing, please <a href="https://github.com/tc39/proposal-bigint/issues/new">file an issue</a>.</p>
</emu-integration-plans>
</emu-intro>
<emu-clause id="sec-numeric-types">
  <h1>Numeric Types</h1>
  <p>ECMAScript has two built-in numeric types: Number and BigInt. In this specification, every numeric type _T_ contains a multiplicative identity value denoted _T_::unit. The specification types also have the following abstract operations, likewise denoted _T_::<i>op</i> for a given operation with specification name <i>op</i>. Unless noted otherwise, argument and result types are all _T_.</p>
  <emu-table id="table-numeric-type-ops" caption="Numeric Type Operations">
    <table>
      <tbody>
      <tr>
        <th>
          Invocation Synopsis
        </th>
        <th>
          Value and Purpose
        </th>
      </tr>
      <tr>
        <td>
          _T_::unaryMinus(x)
        </td>
        <td>
          A specification function invoked when applying the unary minus operator. Called by the semantics of the <emu-xref href="#sec-unary-minus-operator">unary - operator</emu-xref>.
        </td>
      </tr>
      <tr>
        <td>
          _T_::bitwiseNOT(x)
        </td>
        <td>
          A specification function invoked when applying the bitwise NOT operator. Called by the semantics of the <emu-xref href="#sec-bitwise-not-operator">bitwise NOT operator</emu-xref> for `~x`.
        </td>
      </tr>
      <tr>
        <td>
          _T_::exponentiate(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying the exponentiation operator. Called by the semantics of the <emu-xref href="#sec-exp-operator">exponentiation operator</emu-xref> for `x ** y`.
        </td>
      </tr>
      <tr>
        <td>
          _T_::multiply(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying the multiplication operator. Called by the semantics of the <emu-xref href="#sec-applying-the-mul-operator">`*` operator</emu-xref> for `x * y`.
        </td>
      </tr>
      <tr>
        <td>
          _T_::divide(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying the division operator. Called by the semantics of the <emu-xref href="#sec-applying-the-div-operator">`/` operator</emu-xref> for `x / y`.
        </td>
      </tr>
      <tr>
        <td>
          _T_::remainder(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying the truncating remainder ("mod") operator. Called by the semantics of the <emu-xref href="#sec-applying-the-mod-operator">`%` operator</emu-xref> for `x % y`.
          <emu-todo>Revisit this name, as Number::remainder explicitly doesn't do the IEEE 754 remainder operation. However, modulo also seems problematic. (<a href="https://github.com/tc39/proposal-bigint/issues/37">issue</a>)</emu-todo>
        </td>
      </tr>
      <tr>
        <td>
          _T_::add(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying the addition operator. Called by the semantics of the <emu-xref href="#sec-addition-operator-plus">`+` operator</emu-xref> for `x + y`.
        </td>
      </tr>
      <tr>
        <td>
          _T_::subtract(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying the subtraction operator. Called by the semantics of the <emu-xref href="#sec-subtraction-operator-minus">`-` operator</emu-xref> for `x - y`.
        </td>
      </tr>
      <tr>
        <td>
          _T_::leftShift(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying the left shift operator to two operands, both of type _T_. Called by the semantics of the <emu-xref href="#sec-left-shift-operator">`<<` operator</emu-xref> for `x << y`.
        </td>
      </tr>
      <tr>
        <td>
          _T_::signedRightShift(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying the right shift operator to two operands, both of type _T_. Called by the semantics of the <emu-xref href="#sec-signed-right-shift-operator">`>>` operator</emu-xref> for `x >> y`.
        </td>
      </tr>
      <tr>
        <td>
          _T_::unsignedRightShift(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying the right shift operator to two operands, both of type _T_. Called by the semantics of the <emu-xref href="#sec-unsigned-right-shift-operator">`>>>` operator</emu-xref> for `x >>> y`.
        </td>
      </tr>
      <tr>
        <td>
          _T_::lessThan(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying one of the four partial-order <emu-xref href="#sec-relational-operators">relational operators</emu-xref>. The return value must be *false*, *true*, or *undefined* (for unordered inputs). Called by the <emu-xref href="#sec-abstract-relational-comparison">Abstract Relational Comparison</emu-xref> algorithm for `x < y`, `x > y`, `x <= y`, and `x >= y`.
        </td>
      </tr>
      <tr>
        <td>
          _T_::equal(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying <emu-xref href="#sec-equality-operators">equality operators</emu-xref>. The return value must be *false* or *true*. Called by the <emu-xref href="#sec-strict-equality-comparison">Strict Equality Comparison</emu-xref> algorithm for `x == y`, `x != y`, `x === y`, and `x !== y`.
        </td>
      </tr>
      <tr>
        <td>
          _T_::sameValue(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying <emu-xref href="#sec-samevalue">abstract operation SameValue</emu-xref>. The return value must be *false* or *true*. Called from Object internal methods to test exact value equality. May not throw an exception.
        </td>
      </tr>
      <tr>
        <td>
          _T_::sameValueZero(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying <emu-xref href="#sec-samevaluezero">abstract operation SameValueZero</emu-xref>. The return value must be *false* or *true*. Called from Array, Map, and Set methods to test value equality ignoring differences among members of the zero cohort (e.g., *-0* and *+0*). May not throw an exception.
        </td>
      </tr>
      <tr>
        <td>
          _T_::bitwiseAND(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying <emu-xref href="#sec-binary-bitwise-operators">binary bitwise AND operator</emu-xref>. Called by the <emu-xref href="#sec-binary-bitwise-operators-runtime-semantics-evaluation">Binary Bitwise Operators</emu-xref> algorithm for `x &amp; y`.
        </td>
      </tr>
      <tr>
        <td>
          _T_::bitwiseXOR(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying <emu-xref href="#sec-binary-bitwise-operators">binary bitwise XOR operator</emu-xref>. Called by the <emu-xref href="#sec-binary-bitwise-operators-runtime-semantics-evaluation">Binary Bitwise Operators</emu-xref> algorithm for `x ^ y`.
        </td>
      </tr>
      <tr>
        <td>
          _T_::bitwiseOR(x,&nbsp;y)
        </td>
        <td>
          A specification function invoked when applying <emu-xref href="#sec-binary-bitwise-operators">binary bitwise OR operator</emu-xref>. Called by the <emu-xref href="#sec-binary-bitwise-operators-runtime-semantics-evaluation">Binary Bitwise Operators</emu-xref> algorithm for `x | y`.
        </td>
      </tr>
      </tbody>
    </table>
  </emu-table>
  <p>The _T_::unit value and _T_::_op_ operations are not a part of the ECMAScript language; they are defined here solely to aid the specification of the semantics of the ECMAScript language. Other abstract operations are defined throughout this specification.</p>
  <p>Because the numeric types are in general not convertible without loss of precision or truncation, the ECMAScript language provides no implicit conversion among these types. Programmers must explicitly call `Number` and `BigInt` functions to convert among types when calling a function which requires another type.</p>
  <emu-note>
    <p>The first and subsequent editions of ECMAScript have provided, for certain operators, implicit numeric conversions that could lose precision or truncate. These legacy implicit conversions are maintained for backward compatibility, but not provided for BigInt in order to minimize opportunity for programmer error, and to leave open the option of generalized <em>value types</em> in a future edition.</p>
  </emu-note>


  <emu-clause id="sec-ecmascript-language-types-bigint-type">
    <h1>The BigInt Type</h1>
    <p>The BigInt type represents a mathematical integer value. The value may be any size and is not limited to a particular bit-width. Generally, where not otherwise noted, operations are designed to return exact mathematically-based answers. For binary operations, BigInts act as two's complement binary strings, with negative numbers treated as having bits set infinitely to the left.</p>

    <p>The BigInt::unit value is *1n*.</p>

    <emu-clause id="sec-numeric-types-bigint-unaryMinus">
      <h1>BigInt::unaryMinus (_x_)</h1>
      <p>The abstract operation BigInt::unaryMinus with an argument _x_ of BigInt type returns the result of negating _x_.</p>
      <emu-note>There is only one *0n* value; `-0n` is the same as *0n*.</emu-note>
    </emu-clause>

    <emu-clause id="sec-numeric-types-bigint-bitwiseNOT">
      <h1>BigInt::bitwiseNOT (_x_)</h1>
      <p>The abstract operation BigInt::bitwiseNOT with an argument _x_ of BigInt type returns the one's complement of _x_; that is, -_x_ - 1.</p>
    </emu-clause>

    <emu-clause id="sec-numeric-types-bigint-exponentiate">
      <h1>BigInt::exponentiate (_base_, _exponent_)</h1>
      <emu-alg>
        1. If _exponent_ &lt; 0, throw a *RangeError* exception.
        1. If _base_ is *0n* and _exponent_ is *0n*, return *1n*.
        1. Return a BigInt representing the mathematical value of _base_ raised to the power _exponent_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-numeric-types-bigint-multiply">
      <h1>BigInt::multiply (_x_, _y_)</h1>
      <p>The abstract operation BigInt::multiply with two arguments _x_ and _y_ of BigInt type returns a BigInt representing the result of multiplying _x_ and _y_.</p>
      <emu-note>Even if the result has a much larger bit width than the input, the exact mathematical answer is given.</emu-note>
    </emu-clause>

    <emu-clause id="sec-numeric-types-bigint-divide">
      <h1>BigInt::divide (_x_, _y_)</h1>
      <emu-alg>
        1. If _y_ is *0n*, throw a *RangeError* exception.
        1. Let _quotient_ be the mathematical value of _x_ divided by _y_.
        1. Return a BigInt representing _quotient_ rounded towards 0 to the next integral value.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-numeric-types-bigint-remainder">
      <h1>BigInt::remainder (_n_, _d_)</h1>
      <emu-alg>
        1. If _d_ is *0n*, throw a *RangeError* exception.
        1. If _n_ is *0n*, return *0n*.
        1. Let _r_ be the BigInt defined by the mathematical relation _r_ = _n_ - (_d_ &times; _q_) where _q_ is a BigInt that is negative only if _n_/_d_ is negative and positive only if _n_/_d_ is positive, and whose magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of _n_ and _d_.
        1. Return _r_.
      </emu-alg>
      <emu-note>The sign of the result equals the sign of the dividend.</emu-note>
    </emu-clause>

    <emu-clause id="sec-numeric-types-bigint-add">
      <h1>BigInt::add (_x_, _y_)</h1>
      <p>The abstract operation BigInt::add with two arguments _x_ and _y_ of BigInt type returns a BigInt representing the sum of _x_ and _y_.</p>
    </emu-clause>

    <emu-clause id="sec-numeric-types-bigint-subtract">
      <h1>BigInt::subtract (_x_, _y_)</h1>
      <p>The abstract operation BigInt::subtract with two arguments _x_ and _y_ of BigInt type returns the BigInt representing the difference _x_ minus _y_.</p>
    </emu-clause>

    <emu-clause id="sec-numeric-types-bigint-leftShift">
      <h1>BigInt::leftShift (_x_, _y_)</h1>
      <p>The abstract operation BigInt::leftShift with two arguments _x_ and _y_ of BigInt:</p>
      <emu-alg>
        1. If _y_ &lt; 0, then
          1. Return a BigInt representing _x_ &divide; 2<sup>-_y_</sup>, rounding down to the nearest integer, including for negative numbers.
        1. Return a BigInt representing _x_ &times; 2<sup>_y_</sup>.
      </emu-alg>
      <emu-note>Semantics here should be equivalent to a bitwise shift, treating the BigInt as an infinite length string of binary two's complement digits.</emu-note>
    </emu-clause>

    <emu-clause id="sec-numeric-types-bigint-signedRightShift">
      <h1>BigInt::signedRightShift (_x_, _y_)</h1>
      <p>The abstract operation BigInt::signedRightShift with arguments _x_ and _y_ of type BigInt:</p>
      <emu-alg>
        1. Return BigInt::leftShift(_x_, -_y_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-numeric-types-bigint-unsignedRightShift">
      <h1>BigInt::unsignedRightShift (_x_, _y_)</h1>
      <p>The abstract operation BigInt::unsignedRightShift with two arguments _x_ and _y_ of type BigInt:</p>
      <emu-alg>
        1. Throw a *TypeError* exception.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-numeric-types-bigint-lessThan">
      <h1>BigInt::lessThan (_x_, _y_)</h1>
      <p>The abstract operation BigInt::lessThan with two arguments _x_ and _y_ of BigInt type returns *true* if _x_ is less than _y_ and *false* otherwise.</p>
    </emu-clause>

    <emu-clause id="sec-numeric-types-bigint-equal">
      <h1>BigInt::equal (_x_, _y_)</h1>
      <p>The abstract operation BigInt::equal with two arguments _x_ and _y_ of BigInt type returns *true* if _x_ and _y_ have the same mathematical integer value and *false* otherwise.</p>
    </emu-clause>

    <emu-clause id="sec-numeric-types-bigint-sameValue">
      <h1>BigInt::sameValue (_x_, _y_)</h1>
      <p>The abstract operation BigInt::sameValue with two arguments _x_ and _y_ of BigInt type:</p>
      <emu-alg>
        1. Return BigInt::equal(_x_, _y_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-numeric-types-bigint-sameValueZero">
      <h1>BigInt::sameValueZero (_x_, _y_)</h1>
      <p>The abstract operation BigInt::sameValueZero with two arguments _x_ and _y_ of BigInt type:</p>
      <emu-alg>
        1. Return BigInt::equal(_x_, _y_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-bitwise-op">
      <h1>BitwiseOp(_op_, _x_, _y_)</h1>
      <emu-alg>
        1. Let _result_ be 0.
        1. Let _shift_ be 0.
        1. Repeat, until (_x_ = 0 or _x_ = -1) and (_y_ = 0 or _y_ = -1),
          1. Let _xDigit_ be _x_ modulo 2.
          1. Let _yDigit_ be _y_ modulo 2.
          1. Let _result_ be _result_ + 2<sup>_shift_</sup> &times; _op_(_xDigit_, _yDigit_).
          1. Let _shift_ be _shift_ + 1.
          1. Let _x_ be (_x_ - _xDigit_) / 2.
          1. Let _y_ be (_y_ - _yDigit_) / 2.
        1. If _op_(_x_ modulo 2, _y_ modulo 2) &ne; 0, then
          1. Let _result_ be _result_ - 2<sup>_shift_</sup>. NOTE: This extends the sign.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-numeric-types-bigint-bitwiseAND">
      <h1>BigInt::bitwiseAND (_x_, _y_)</h1>
      <emu-alg>
        1. Return BitwiseOp(`&amp;`, _x_, _y_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-numeric-types-bigint-bitwiseXOR">
      <h1>BigInt::bitwiseXOR (_x_, _y_)</h1>
      <emu-alg>
        1. Return BitwiseOp(`^`, _x_, _y_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-numeric-types-bigint-bitwiseOR">
      <h1>BigInt::bitwiseOR (_x_, _y_)</h1>
      <emu-alg>
        1. Return BitwiseOp(`|`, _x_, _y_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-integration-plans>
    As part of the integration with the main specification, the Number type will have a similar definition of operations, derived from the current operator definitions. Because the semantics are not proposed to change, for ease of review, the refactoring is omitted from this spec draft.
  </emu-integration-plans>
</emu-clause>

<emu-clause id="sec-grammar-change">
  <h1>Modifications to the Number grammar</h1>
  <emu-grammar>
    NumericLiteral ::
      DecimalLiteral
      <ins>DecimalIntegerLiteral BigIntLiteralSuffix</ins>
      <del>BinaryIntegerLiteral</del>
      <del>OctalIntegerLiteral</del>
      <del>HexIntegerLiteral</del>
      <ins>NumericLiteralBase</ins>
      <ins>NumericLiteralBase BigIntLiteralSuffix</ins>
      LegacyOctalIntegerLiteral

    <ins>NumericLiteralBase ::
          BinaryIntegerLiteral
          OctalIntegerLiteral
          HexIntegerLiteral</ins>

    <ins>BigIntLiteralSuffix :: `n`</ins>
  </emu-grammar>

  <emu-clause id="sec-numeric-literal-static-semantics-bigint-value">
    <h1>Static Semantics: BigInt Value</h1>
    <emu-grammar>NumericLiteral :: NumericLiteralBase BigIntLiteralSuffix</emu-grammar>
    <ul>
      <li>
        Let the value of |NumericLiteral| be the MV of |NumericLiteralBase| represented as BigInt.
      </li>
    </ul>
    <emu-grammar>NumericLiteral :: DecimalIntegerLiteral BigIntLiteralSuffix</emu-grammar>
    <ul>
      <li>
        Let the value of |NumericLiteral| be the MV of |DecimalIntegerLiteral| represented as BigInt.
      </li>
    </ul>
  </emu-clause>

  <emu-clause id="sec-numeric-literal-static-semantics-number-value">
    <h1>Static Semantics: Number Value</h1>
    <emu-grammar>NumericLiteral :: NumericLiteralBase</emu-grammar>
    <p>The MV is rounded to a value of the Number type.</p>

    <emu-integration-plans>
      Rounding to the nearest Number will be moved from the MV calculation to a Number Value Static Semantics section so that it doesn't apply to BigInts.
    </emu-integration-plans>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-abstract-operations">
  <h1>Abstract Operations</h1>
  <emu-clause id="sec-type-conversion">
    <h1>Type Conversion</h1>
    <p>The BigInt type has no implicit conversions in the ECMAScript language; programmers must call BigInt explicitly to convert values from other types.</p>

    <emu-clause id="sec-toprimitive" aoid="ToPrimitive">
      <h1>ToPrimitive ( _input_ [ , _PreferredType_ ] )</h1>
      <emu-table id="table-9" caption="ToPrimitive Conversions">
        <table>
          <tbody>
          <tr>
            <th>
              Input Type
            </th>
            <th>
              Result
            </th>
          </tr>
          <tr>
            <td>
              <ins>BigInt</ins>
            </td>
            <td>
              <ins>Return _input_.</ins>
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-toboolean" aoid="ToBoolean">
      <h1>ToBoolean ( _argument_ )</h1>
      <p>The abstract operation ToBoolean converts _argument_ to a value of type Boolean according to <emu-xref href="#table-10"></emu-xref>:</p>
      <emu-table id="table-10" caption="ToBoolean Conversions">
        <table>
          <tbody>
          <tr>
            <th>
              Argument Type
            </th>
            <th>
              Result
            </th>
          </tr>
          <tr>
            <td>
              <ins>BigInt</ins>
            </td>
            <td>
              <ins>Return *false* if _argument_ is *0n*; otherwise return *true*.</ins>
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-tonumber" aoid="ToNumber">
      <h1>ToNumber ( _argument_ )</h1>
      <p>The abstract operation ToNumber converts _argument_ to a value of type Number according to <emu-xref href="#table-11"></emu-xref>:</p>
      <emu-table id="table-11" caption="ToNumber Conversions">
        <table>
          <tbody>
          <tr>
            <th>
              Argument Type
            </th>
            <th>
              Result
            </th>
          </tr>
          <tr>
            <td>
              <ins>BigInt</ins>
            </td>
            <td>
              <ins>Throw a *TypeError* exception</ins>
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
      <emu-motivation>
        Although it would be possible to define a conversion here, to find the nearest Number for a BigInt, such a conversion may lose precision. ToNumber is called implicitly from so many places, but BigInts would not add any value if they lost precision all the time; you might as well just use Numbers instead in the first place. A key <a href="https://github.com/tc39/proposal-bigint/blob/master/README.md#no-implicit-conversions-or-mixed-operands">design decision</a> of this specification is to disallow implicit conversions, and force programmers to use explicit conversions themselves instead.
      </emu-motivation>

      <emu-clause id="sec-tonumber-applied-to-the-string-type">
        <h1>ToNumber Applied to the String Type</h1>
        <emu-note>
          <p>Some differences should be noted between the syntax of a |StringNumericLiteral| and a |NumericLiteral|:</p>
          <ul>
            <li>
              <ins>A |StringNumericLiteral| may not include a |BigIntLiteralSuffix|.</ins>
            </li>
          </ul>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-tostring" aoid="ToString">
      <h1>ToString ( _argument_ )</h1>
      <p>The abstract operation ToString converts _argument_ to a value of type String according to <emu-xref href="#table-12"></emu-xref>:</p>
      <emu-table id="table-12" caption="ToString Conversions">
        <table>
          <tbody>
          <tr>
            <th>
              Argument Type
            </th>
            <th>
              Result
            </th>
          </tr>
          <tr>
            <td>
              BigInt
            </td>
            <td>
              See <emu-xref href="#sec-tostring-applied-to-the-bigint-type"></emu-xref>.
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>

      <emu-clause id="sec-tostring-applied-to-the-bigint-type" aoid="ToString Applied to the BigInt Type">
        <h1>ToString Applied to the BigInt Type</h1>
        <p>The abstract operation ToString converts a BigInt _i_ to String format as follows:</p>
        <emu-alg>
          1. If _i_ is less than zero, return the string-concatenation of the String `"-"` and ToString(-_i_).
          1. Return the String value consisting of the code units of the digits of the decimal representation of _i_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-toobject" aoid="ToObject">
      <h1>ToObject ( _argument_ )</h1>
      <p>The abstract operation ToObject converts _argument_ to a value of type Object according to <emu-xref href="#table-13"></emu-xref>:</p>
      <emu-table id="table-13" caption="ToObject Conversions">
        <table>
          <tbody>
          <tr>
            <th>
              Argument Type
            </th>
            <th>
              Result
            </th>
          </tr>
          <tr>
            <td>
              <ins>BigInt</ins>
            </td>
            <td>
              <ins>Return a new BigInt object whose [[BigIntData]] internal slot is set to _argument_. See <a href="#sec-bigint-objects">BigInt Objects</a> for a description of BigInt objects.</ins>
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-tonumeric" aoid="ToNumeric">
      <h1>ToNumeric ( _value_ )</h1>
      <p>The abstract operation ToNumeric returns _value_ converted to a numeric value of type Number or BigInt. This abstract operation functions as follows:</p>
      <emu-alg>
        1. Let _primValue_ be ? ToPrimitive(_value_, hint Number).
        1. If Type(_primValue_) is BigInt, return _primValue_.
        1. Return ToNumber(_primValue_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-requireobjectcoercible" aoid="RequireObjectCoercible">
      <h1>RequireObjectCoercible ( _argument_ )</h1>
      <p>The abstract operation RequireObjectCoercible throws an error if _argument_ is a value that cannot be converted to an Object using ToObject. It is defined by <emu-xref href="#table-14"></emu-xref>:</p>
      <emu-table id="table-14" caption="RequireObjectCoercible Results">
        <table>
          <tbody>
          <tr>
            <th>
              Argument Type
            </th>
            <th>
              Result
            </th>
          </tr>
          <tr>
            <td>
              BigInt
            </td>
            <td>
              Return _argument_.
            </td>
          </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-testing-and-comparison-operations">
    <h1>Testing and Comparison Operations</h1>
    <emu-clause id="sec-samevalue" aoid="SameValue">
      <h1>SameValue ( _x_, _y_ )</h1>
      <p>The internal comparison abstract operation SameValue(_x_, _y_), where _x_ and _y_ are ECMAScript language values, produces *true* or *false*. Such a comparison is performed as follows:</p>
      <emu-alg>
        1. If Type(_x_) is different from Type(_y_), return *false*.
        1. If Type(_x_) is Number <ins>or BigInt</ins>, then
          1. <del>If _x_ is *NaN* and _y_ is *NaN*, return *true*.</del>
          1. <del>If _x_ is *+0* and _y_ is *-0*, return *false*.</del>
          1. <del>If _x_ is *-0* and _y_ is *+0*, return *false*.</del>
          1. <del>If _x_ is the same Number value as _y_, return *true*.</del>
          1. <del>Return *false*.</del>
          1. <ins>Return ! Type(_x_)::sameValue(_x_, _y_).</ins>
        1. Return <a href="sec-samevaluenonnumber">SameValueNon<del>Number</del><ins>Numeric</ins></a>(_x_, _y_).
      </emu-alg>
      <emu-integration-plans>The previous Number-related contents of this algorithm will be moved into Number::sameValue.</emu-integration-plans>
    </emu-clause>

    <!-- es6num="7.2.10" -->
    <emu-clause id="sec-samevaluezero" aoid="SameValueZero">
      <h1>SameValueZero ( _x_, _y_ )</h1>
      <p>The internal comparison abstract operation SameValueZero(_x_, _y_), where _x_ and _y_ are ECMAScript language values, produces *true* or *false*. Such a comparison is performed as follows:</p>
      <emu-alg>
        1. If Type(_x_) is different from Type(_y_), return *false*.
        1. If Type(_x_) is Number <ins>or BigInt</ins>, then
          1. <del>If _x_ is *NaN* and _y_ is *NaN*, return *true*.</del>
          1. <del>If _x_ is *+0* and _y_ is *-0*, return *true*.</del>
          1. <del>If _x_ is *-0* and _y_ is *+0*, return *true*.</del>
          1. <del>If _x_ is the same Number value as _y_, return *true*.</del>
          1. <del>Return *false*.</del>
          1. <ins>Return ! Type(_x_)::sameValueZero(_x_, _y_).</ins>
        1. Return <a href="sec-samevaluenonnumber">SameValueNon<del>Number</del><ins>Numeric</ins></a>(_x_, _y_).
      </emu-alg>
      <emu-integration-plans>The previous Number-related contents of this algorithm will be moved into Number::sameValueZero.</emu-integration-plans>
    </emu-clause>

    <emu-clause id="sec-samevaluenonnumber" aoid="SameValueNonNumeric">
      <h1>SameValueNon<del>Number</del><ins>Numeric</ins> ( _x_, _y_ )</h1>
      <p>The internal comparison abstract operation SameValueNonNumeric(_x_, _y_), where neither _x_ nor _y_ are numeric type values, produces *true* or *false*. Such a comparison is performed as follows:</p>
      <emu-alg>
        1. Assert: Type(_x_) is not Number <ins>or BigInt</ins>.
        1. Assert: Type(_x_) is the same as Type(_y_).
        1. If Type(_x_) is Undefined, return *true*.
        1. If Type(_x_) is Null, return *true*.
        1. If Type(_x_) is String, then
          1. If _x_ and _y_ are exactly the same sequence of code units (same length and same code units at corresponding indices), return *true*; otherwise, return *false*.
        1. If Type(_x_) is Boolean, then
          1. If _x_ and _y_ are both *true* or both *false*, return *true*; otherwise, return *false*.
        1. If Type(_x_) is Symbol, then
          1. If _x_ and _y_ are both the same Symbol value, return *true*; otherwise, return *false*.
        1. If _x_ and _y_ are the same Object value, return *true*. Otherwise, return *false*.
      </emu-alg>
    </emu-clause>

    <!-- es6num="7.2.11" -->
    <emu-clause id="sec-abstract-relational-comparison" aoid="Abstract Relational Comparison">
      <h1>Abstract Relational Comparison</h1>
      <p>The comparison _x_ &lt; _y_, where _x_ and _y_ are values, produces *true*, *false*, or *undefined* (which indicates that at least one operand is *NaN*). In addition to _x_ and _y_ the algorithm takes a Boolean flag named _LeftFirst_ as a parameter. The flag is used to control the order in which operations with potentially visible side-effects are performed upon _x_ and _y_. It is necessary because ECMAScript specifies left to right evaluation of expressions. The default value of _LeftFirst_ is *true* and indicates that the _x_ parameter corresponds to an expression that occurs to the left of the _y_ parameter's corresponding expression. If _LeftFirst_ is *false*, the reverse is the case and operations must be performed upon _y_ before _x_. Such a comparison is performed as follows:</p>
      <emu-alg>
        1. If the _LeftFirst_ flag is *true*, then
          1. Let _px_ be ? ToPrimitive(_x_, hint Number).
          1. Let _py_ be ? ToPrimitive(_y_, hint Number).
        1. Else the order of evaluation needs to be reversed to preserve left to right evaluation,
          1. Let _py_ be ? ToPrimitive(_y_, hint Number).
          1. Let _px_ be ? ToPrimitive(_x_, hint Number).
        1. If both _px_ and _py_ are Strings, then
          1. If _py_ is a prefix of _px_, return *false*. (A String value _p_ is a prefix of String value _q_ if _q_ can be the result of concatenating _p_ and some other String _r_. Note that any String is a prefix of itself, because _r_ may be the empty String.)
          1. If _px_ is a prefix of _py_, return *true*.
          1. Let _k_ be the smallest nonnegative integer such that the code unit at index _k_ within _px_ is different from the code unit at index _k_ within _py_. (There must be such a _k_, for neither String is a prefix of the other.)
          1. Let _m_ be the integer that is the code unit at index _k_ within _px_.
          1. Let _n_ be the integer that is the code unit at index _k_ within _py_.
          1. If _m_ &lt; _n_, return *true*. Otherwise, return *false*.
        1. Else,
          1. <del>Let _nx_ be ? ToNumber(_px_). Because _px_ and _py_ are primitive values evaluation order is not important.</del>
          1. <del>Let _ny_ be ? ToNumber(_py_).</del>
          1. <del>If _nx_ is *NaN*, return *undefined*.</del>
          1. <del>If _ny_ is *NaN*, return *undefined*.</del>
          1. <del>If _nx_ and _ny_ are the same Number value, return *false*.</del>
          1. <del>If _nx_ is *+0* and _ny_ is *-0*, return *false*.</del>
          1. <del>If _nx_ is *-0* and _ny_ is *+0*, return *false*.</del>
          1. <del>If _nx_ is *+&infin;*, return *false*.</del>
          1. <del>If _ny_ is *+&infin;*, return *true*.</del>
          1. <del>If _ny_ is *-&infin;*, return *false*.</del>
          1. <del>If _nx_ is *-&infin;*, return *true*.</del>
          1. <del>If the mathematical value of _nx_ is less than the mathematical value of _ny_ &mdash;note that these mathematical values are both finite and not both zero&mdash;return *true*. Otherwise, return *false*.</del>
          1. <ins>If Type(_px_) is BigInt and Type(_py_) is String, then</ins>
            1. <ins>Let _ny_ be StringToBigInt(_py_).</ins>
            1. <ins>If _ny_ is *NaN*, return *undefined*.</ins>
            1. <ins>Return BigInt::lessThan(_px_, _ny_).</ins>
          1. <ins>If Type(_px_) is String and Type(_py_) is BigInt, then</ins>
            1. <ins>Let _nx_ be StringToBigInt(_px_).</ins>
            1. <ins>If _nx_ is *NaN*, return *undefined*.</ins>
            1. <ins>Return BigInt::lessThan(_nx_, _py_).</ins>
          1. <ins>Let _nx_ be ? ToNumeric(_px_). Because _px_ and _py_ are primitive values evaluation order is not important.</ins>
          1. <ins>Let _ny_ be ? ToNumeric(_py_).</ins>
          1. <ins>If Type(_nx_) is the same as Type(_ny_), return ? Type(_nx_)::lessThan(_nx_, _ny_).</ins>
          1. <ins>Assert: Type(_nx_) is BigInt and Type(_ny_) is Number, or Type(_nx_) is Number and Type(_ny_) is BigInt.</ins>
          1. <ins>If _x_ or _y_ is *NaN*, return *undefined*.</ins>
          1. <ins>If _x_ is *-&infin;* or _y_ is *+&infin;*, return *true*.</ins>
          1. <ins>If _x_ is *+&infin;* or _y_ is *-&infin;*, return *false*.</ins>
          1. <ins>If the mathematical value of _nx_ is less than the mathematical value of _ny_, return *true*, otherwise return *false*.</ins>
      </emu-alg>
      <emu-integration-plans>The previous Number-related contents of this algorithm will be moved into Number::lessThan.</emu-integration-plans>
    </emu-clause>

    <!-- es6num="7.2.12" -->
    <emu-clause id="sec-abstract-equality-comparison" aoid="Abstract Equality Comparison">
      <h1>Abstract Equality Comparison</h1>
      <p>The comparison _x_ == _y_, where _x_ and _y_ are values, produces *true* or *false*. Such a comparison is performed as follows:</p>
      <emu-alg>
        1. If Type(_x_) is the same as Type(_y_), then
          1. Return the result of performing Strict Equality Comparison _x_ === _y_.
        1. If _x_ is *null* and _y_ is *undefined*, return *true*.
        1. If _x_ is *undefined* and _y_ is *null*, return *true*.
        1. If Type(_x_) is Number and Type(_y_) is String, return the result of the comparison _x_ == ToNumber(_y_).
        1. If Type(_x_) is String and Type(_y_) is Number, return the result of the comparison ToNumber(_x_) == _y_.
        1. <ins>If Type(_x_) is BigInt and Type(_y_) is String, then</ins>
          1. <ins>Let _n_ be StringToBigInt(_y_).</ins>
          1. <ins>If _n_ is *NaN*, return *false*.</ins>
          1. <ins>Return the result of the comparison _x_ == _n_.</ins>
        1. <ins>If Type(_x_) is String and Type(_y_) is BigInt, return the result of the comparison _y_ == _x_.</ins>
        1. If Type(_x_) is Boolean, return the result of the comparison ToNumber(_x_) == _y_.
        1. If Type(_y_) is Boolean, return the result of the comparison _x_ == ToNumber(_y_).
        1. If Type(_x_) is either String, Number, <ins>BigInt,</ins> or Symbol and Type(_y_) is Object, return the result of the comparison _x_ == ? ToPrimitive(_y_).
        1. If Type(_x_) is Object and Type(_y_) is either String, Number, <ins>BigInt,</ins> or Symbol, return the result of the comparison ? ToPrimitive(_x_) == _y_.
        1. <ins>If Type(_x_) is BigInt and Type(_y_) is Number, or if Type(_x_) is Number and Type(_y_) is BigInt, then</ins>
          1. <ins>If _x_ or _y_ are any of *NaN*, *+&infin;*, or *-&infin;*, return *false*.</ins>
          1. <ins>If the mathematical value of _x_ is equal to the mathematical value of _y_, return *true*, otherwise return *false*.</ins>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <!-- es6num="7.2.13" -->
    <emu-clause id="sec-strict-equality-comparison" aoid="Strict Equality Comparison">
      <h1>Strict Equality Comparison</h1>
      <p>The comparison _x_ === _y_, where _x_ and _y_ are values, produces *true* or *false*. Such a comparison is performed as follows:</p>
      <emu-alg>
        1. If Type(_x_) is different from Type(_y_), return *false*.
        1. If Type(_x_) is Number <ins>or BigInt</ins>, then
          1. <del>If _x_ is *NaN*, return *false*.</del>
          1. <del>If _y_ is *NaN*, return *false*.</del>
          1. <del>If _x_ is the same Number value as _y_, return *true*.</del>
          1. <del>If _x_ is *+0* and _y_ is *-0*, return *true*.</del>
          1. <del>If _x_ is *-0* and _y_ is *+0*, return *true*.</del>
          1. <del>Return *false*.</del>
          1. <ins>Return ! Type(_x_)::equal(_x_, _y_).</ins>
        1. Return <a href="sec-samevaluenonnumber">SameValueNon<del>Number</del><ins>Numeric</ins></a>(_x_, _y_).
      </emu-alg>
      <emu-integration-plans>The previous Number-related contents of this algorithm will be moved into Number::equal.</emu-integration-plans>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-expressions">
  <h1>ECMAScript Language: Expressions</h1>

  <emu-clause id="sec-update-expressions">
    <h1>Update Expressions</h1>

    <!-- es6num="12.4.4" -->
    <emu-clause id="sec-postfix-increment-operator">
      <h1>Postfix Increment Operator</h1>

      <!-- es6num="12.4.4.1" -->
      <emu-clause id="sec-postfix-increment-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UpdateExpression : LeftHandSideExpression `++`</emu-grammar>
        <emu-alg>
          1. Let _lhs_ be the result of evaluating |LeftHandSideExpression|.
          1. <del>Let _oldValue_ be ? ToNumber(? GetValue(_lhs_)).</del>
          1. <del>Let _newValue_ be the result of adding the value 1 to _oldValue_, using the same rules as for the `+` operator (see <emu-xref href="#sec-applying-the-additive-operators-to-numbers"></emu-xref>).</del>
          1. <ins>Let _oldValue_ be ? ToNumeric(? GetValue(_lhs_)).</ins>
          1. <ins>Let _newValue_ be ? Type(_oldvalue_)::add(_oldValue_, Type(_oldValue_)::unit).</ins>
          1. Perform ? PutValue(_lhs_, _newValue_).
          1. Return _oldValue_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <!-- es6num="12.4.5" -->
    <emu-clause id="sec-postfix-decrement-operator">
      <h1>Postfix Decrement Operator</h1>

      <!-- es6num="12.4.5.1" -->
      <emu-clause id="sec-postfix-decrement-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UpdateExpression : LeftHandSideExpression `--`</emu-grammar>
        <emu-alg>
          1. Let _lhs_ be the result of evaluating |LeftHandSideExpression|.
          1. <del>Let _oldValue_ be ? ToNumber(? GetValue(_lhs_)).</del>
          1. <del>Let _newValue_ be the result of subtracting the value 1 from _oldValue_, using the same rules as for the `-` operator (see <emu-xref href="#sec-applying-the-additive-operators-to-numbers"></emu-xref>).</del>
          1. <ins>Let _oldValue_ be ? ToNumeric(? GetValue(_lhs_)).</ins>
          1. <ins>Let _newValue_ be ? Type(_oldvalue_)::subtract(_oldValue_, Type(_oldValue_)::unit).</ins>
          1. Perform ? PutValue(_lhs_, _newValue_).
          1. Return _oldValue_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <!-- es6num="12.5.7" -->
    <emu-clause id="sec-prefix-increment-operator">
      <h1>Prefix Increment Operator</h1>

      <!-- es6num="12.5.7.1" -->
      <emu-clause id="sec-prefix-increment-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UpdateExpression : `++` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _expr_ be the result of evaluating |UnaryExpression|.
          1. <del>Let _oldValue_ be ? ToNumber(? GetValue(_expr_)).</del>
          1. <del>Let _newValue_ be the result of adding the value 1 to _oldValue_, using the same rules as for the `+` operator (see <emu-xref href="#sec-applying-the-additive-operators-to-numbers"></emu-xref>).</del>
          1. <ins>Let _oldValue_ be ? ToNumeric(? GetValue(_expr_)).</ins>
          1. <ins>Let _newValue_ be ? Type(_oldvalue_)::add(_oldValue_, Type(_oldValue_)::unit).</ins>
          1. Perform ? PutValue(_expr_, _newValue_).
          1. Return _newValue_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <!-- es6num="12.5.8" -->
    <emu-clause id="sec-prefix-decrement-operator">
      <h1>Prefix Decrement Operator</h1>

      <!-- es6num="12.5.8.1" -->
      <emu-clause id="sec-prefix-decrement-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UpdateExpression : `--` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _expr_ be the result of evaluating |UnaryExpression|.
          1. <del>Let _oldValue_ be ? ToNumber(? GetValue(_expr_)).</del>
          1. <del>Let _newValue_ be the result of subtracting the value 1 from _oldValue_, using the same rules as for the `-` operator (see <emu-xref href="#sec-applying-the-additive-operators-to-numbers"></emu-xref>).</del>
          1. <ins>Let _oldValue_ be ? ToNumeric(? GetValue(_expr_)).</ins>
          1. <ins>Let _newValue_ be ? Type(_oldvalue_)::subtract(_oldValue_, Type(_oldValue_)::unit).</ins>
          1. Perform ? PutValue(_expr_, _newValue_).
          1. Return _newValue_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  <emu-clause id="sec-unary-operators">
    <h1>Unary Operators</h1>
    <!-- es6num="12.5.6" -->
    <emu-clause id="sec-typeof-operator">
      <h1>The `typeof` Operator</h1>

      <!-- es6num="12.5.6.1" -->
      <emu-clause id="sec-typeof-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UnaryExpression : `typeof` UnaryExpression</emu-grammar>
        <emu-table id="table-35" caption="typeof Operator Results">
          <table>
            <tbody>
            <tr>
              <th>
                Type of _val_
              </th>
              <th>
                Result
              </th>
            </tr>
            <tr>
              <td>
                <ins>BigInt</ins>
              </td>
              <td>
                <ins>`"bigint"`</ins>
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>

    <!-- es6num="12.5.9" -->
    <emu-clause id="sec-unary-plus-operator">
      <h1>Unary `+` Operator</h1>
      <emu-note>
        <p>The unary + operator converts its operand to Number type.</p>
      </emu-note>

      <!-- es6num="12.5.9.1" -->
      <emu-clause id="sec-unary-plus-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UnaryExpression : `+` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _expr_ be the result of evaluating |UnaryExpression|.
          1. Return ? ToNumber(? GetValue(_expr_)).
        </emu-alg>
        <emu-motivation>The definition here is unchanged, and still uses ToNumber rather than ToNumeric. This means that `+` will throw on BigInts. The semantics here are designed to allow expressions of the form `+x` to always return Numbers, which is necessary to <a href="https://github.com/tc39/proposal-bigint/blob/master/README.md#dont-break-asmjs">preserve assumptions made by asm.js</a>.</emu-motivation>
      </emu-clause>
    </emu-clause>

    <!-- es6num="12.5.10" -->
    <emu-clause id="sec-unary-minus-operator">
      <h1>Unary `-` Operator</h1>
      <emu-note>
        <p>The unary `-` operator converts its operand to Number type and then negates it. Negating *+0* produces *-0*, and negating *-0* produces *+0*.</p>
      </emu-note>

      <!-- es6num="12.5.10.1" -->
      <emu-clause id="sec-unary-minus-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UnaryExpression : `-` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _expr_ be the result of evaluating |UnaryExpression|.
          1. Let _oldValue_ be ? <del>ToNumber</del><ins>ToNumeric</ins>(? GetValue(_expr_)).
          1. <del>If _oldValue_ is *NaN*, return *NaN*.</del>
          1. <del>Return the result of negating _oldValue_; that is, compute a Number with the same magnitude but opposite sign.</del>
          1. <ins>Let _T_ be Type(_oldValue_).</ins>
          1. <ins>Return ? _T_::unaryMinus(_oldValue_).</ins>
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <!-- es6num="12.5.11" -->
    <emu-clause id="sec-bitwise-not-operator">
      <h1>Bitwise NOT Operator ( `~` )</h1>

      <!-- es6num="12.5.11.1" -->
      <emu-clause id="sec-bitwise-not-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>UnaryExpression : `~` UnaryExpression</emu-grammar>
        <emu-alg>
          1. Let _expr_ be the result of evaluating |UnaryExpression|.
          1. Let _oldValue_ be ? <del>ToInt32</del><ins>ToNumeric</ins>(? GetValue(_expr_)).
          1. <del>Return the result of applying bitwise complement to _oldValue_. The result is a signed 32-bit integer.</del>
          1. <ins>Let _T_ be Type(_oldValue_).</ins>
          1. <ins>Return ? _T_::bitwiseNOT(_oldValue_).</ins>
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-exp-operator">
    <h1>Exponentiation Operator</h1>
    <emu-clause id="sec-exp-operator-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>
        ExponentiationExpression : UpdateExpression `**` ExponentiationExpression
      </emu-grammar>
      <emu-alg>
        1. Let _left_ be the result of evaluating _UpdateExpression_.
        1. Let _leftValue_ be ? GetValue(_left_).
        1. Let _right_ be the result of evaluating _ExponentiationExpression_.
        1. Let _rightValue_ be ? GetValue(_right_).
        1. Let _base_ be ? <del>ToNumber</del><ins>ToNumeric</ins>(_leftValue_).
        1. Let _exponent_ be ? <del>ToNumber</del><ins>ToNumeric</ins>(_rightValue_).
        1. <del>Return the result of <emu-xref href="#sec-applying-the-exp-operator" title>Applying the ** operator</emu-xref> with _base_ and _exponent_ as specified in <emu-xref href="#sec-applying-the-exp-operator"></emu-xref>.</del>
        1. <ins>If Type(_base_) is different from Type(_exponent_), throw a *TypeError* exception.</ins>
        1. <ins>Return ? Type(_base_)::exponentiate(_base_, _exponent_).</ins>
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <!-- es6num="12.6" -->
  <emu-clause id="sec-multiplicative-operators">
    <h1>Multiplicative Operators</h1>
    <!-- es6num="12.6.3" -->
    <emu-clause id="sec-multiplicative-operators-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>MultiplicativeExpression : MultiplicativeExpression MultiplicativeOperator ExponentiationExpression</emu-grammar>
      <emu-alg>
        1. Let _left_ be the result of evaluating |MultiplicativeExpression|.
        1. Let _leftValue_ be ? GetValue(_left_).
        1. Let _right_ be the result of evaluating |ExponentiationExpression|.
        1. Let _rightValue_ be ? GetValue(_right_).
        1. Let _lnum_ be ? <del>ToNumber</del><ins>ToNumeric</ins>(_leftValue_).
        1. Let _rnum_ be ? <del>ToNumber</del><ins>ToNumeric</ins>(_rightValue_).
        1. <del>Return the result of applying the |MultiplicativeOperator| (`*`, `/`, or `%`) to _lnum_ and _rnum_ as specified in <emu-xref href="#sec-applying-the-mul-operator"></emu-xref>, <emu-xref href="#sec-applying-the-div-operator"></emu-xref>, or <emu-xref href="#sec-applying-the-mod-operator"></emu-xref>.</del>
        1. <ins>If Type(_lnum_) is different from Type(_rnum_), throw a *TypeError* exception.</ins>
        1. <ins>Let _T_ be Type(_lnum_).</ins>
        1. <ins>If |MultiplicativeOperator| is `*`, return _T_::multiply(_lnum_, _rnum_).</ins>
        1. <ins>If |MultiplicativeOperator| is `/`, return _T_::divide(_lnum_, _rnum_).</ins>
        1. <ins>Otherwise, |MultiplicativeOperator| is `%`; return _T_::remainder(_lnum_, _rnum_).</ins>
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <!-- es6num="12.7" -->
  <emu-clause id="sec-additive-operators">
    <h1>Additive Operators</h1>
    <emu-clause id="sec-addition-operator-plus">
      <h1>The Addition Operator ( `+` )</h1>
      <emu-note>
        <p>The addition operator either performs string concatenation or numeric addition.</p>
      </emu-note>

      <!-- es6num="12.7.3.1" -->
      <emu-clause id="sec-addition-operator-plus-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>AdditiveExpression : AdditiveExpression `+` MultiplicativeExpression</emu-grammar>
        <emu-alg>
          1. Let _lref_ be the result of evaluating |AdditiveExpression|.
          1. Let _lval_ be ? GetValue(_lref_).
          1. Let _rref_ be the result of evaluating |MultiplicativeExpression|.
          1. Let _rval_ be ? GetValue(_rref_).
          1. Let _lprim_ be ? ToPrimitive(_lval_).
          1. Let _rprim_ be ? ToPrimitive(_rval_).
          1. If Type(_lprim_) is String or Type(_rprim_) is String, then
            1. Let _lstr_ be ? ToString(_lprim_).
            1. Let _rstr_ be ? ToString(_rprim_).
            1. Return the string-concatenation of _lstr_ and _rstr_.
          1. Let _lnum_ be ? <del>ToNumber</del><ins>ToNumeric</ins>(_lprim_).
          1. Let _rnum_ be ? <del>ToNumber</del><ins>ToNumeric</ins>(_rprim_).
          1. <del>Return the result of applying the addition operation to _lnum_ and _rnum_. See the Note below <emu-xref href="#sec-applying-the-additive-operators-to-numbers"></emu-xref>.</del>
          1. <ins>If Type(_lnum_) is different from Type(_rnum_), throw a *TypeError* exception.</ins>
          1. <ins>Let _T_ be Type(_lnum_).</ins>
          1. <ins>Return _T_::add(_lnum_, _rnum_).</ins>
        </emu-alg>
        <emu-note>
          <p>No hint is provided in the calls to ToPrimitive in steps 5 and 6. All standard objects except Date objects handle the absence of a hint as if the hint Number were given; Date objects handle the absence of a hint as if the hint String were given. Exotic objects may handle the absence of a hint in some other manner.</p>
        </emu-note>
        <emu-note>
          <p>Step 7 differs from step 5 of the Abstract Relational Comparison algorithm, by using the logical-or operation instead of the logical-and operation.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>

    <!-- es6num="12.7.4" -->
    <emu-clause id="sec-subtraction-operator-minus">
      <h1>The Subtraction Operator ( `-` )</h1>

      <!-- es6num="12.7.4.1" -->
      <emu-clause id="sec-subtraction-operator-minus-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>AdditiveExpression : AdditiveExpression `-` MultiplicativeExpression</emu-grammar>
        <emu-alg>
          1. Let _lref_ be the result of evaluating |AdditiveExpression|.
          1. Let _lval_ be ? GetValue(_lref_).
          1. Let _rref_ be the result of evaluating |MultiplicativeExpression|.
          1. Let _rval_ be ? GetValue(_rref_).
          1. Let _lnum_ be ? <del>ToNumber</del><ins>ToNumeric</ins>(_lval_).
          1. Let _rnum_ be ? <del>ToNumber</del><ins>ToNumeric</ins>(_rval_).
          1. <del>Return the result of applying the subtraction operation to _lnum_ and _rnum_. See the note below <emu-xref href="#sec-applying-the-additive-operators-to-numbers"></emu-xref>.</del>
          1. <ins>If Type(_lnum_) is different from Type(_rnum_), throw a *TypeError* exception.</ins>
          1. <ins>Let _T_ be Type(_lnum_).</ins>
          1. <ins>Return _T_::subtract(_lnum_, _rnum_).</ins>
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <!-- es6num="12.8" -->
  <emu-clause id="sec-bitwise-shift-operators">
    <h1>Bitwise Shift Operators</h1>

    <!-- es6num="12.8.3" -->
    <emu-clause id="sec-left-shift-operator">
      <h1>The Left Shift Operator ( `&lt;&lt;` )</h1>
      <emu-note>
        <p>Performs a bitwise left shift operation on the left operand by the amount specified by the right operand.</p>
      </emu-note>

      <!-- es6num="12.8.3.1" -->
      <emu-clause id="sec-left-shift-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>ShiftExpression : ShiftExpression `&lt;&lt;` AdditiveExpression</emu-grammar>
        <emu-alg>
          1. Let _lref_ be the result of evaluating |ShiftExpression|.
          1. Let _lval_ be ? GetValue(_lref_).
          1. Let _rref_ be the result of evaluating |AdditiveExpression|.
          1. Let _rval_ be ? GetValue(_rref_).
          1. Let _lnum_ be ? <del>ToInt32</del><ins>ToNumeric</ins>(_lval_).
          1. Let _rnum_ be ? <del>ToUint32</del><ins>ToNumeric</ins>(_rval_).
          1. <del>Let _shiftCount_ be the result of masking out all but the least significant 5 bits of _rnum_, that is, compute _rnum_ &amp; 0x1F.</del>
          1. <del>Return the result of left shifting _lnum_ by _shiftCount_ bits. The result is a signed 32-bit integer.</del>
          1. <ins>If Type(_lnum_) is different from Type(_rnum_), throw a *TypeError* exception.</ins>
          1. <ins>Let _T_ be Type(_lnum_).</ins>
          1. <ins>Return _T_::leftShift(_lnum_, _rnum_).</ins>
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <!-- es6num="12.8.4" -->
    <emu-clause id="sec-signed-right-shift-operator">
      <h1>The Signed Right Shift Operator ( `&gt;&gt;` )</h1>
      <emu-note>
        <p>Performs a sign-filling bitwise right shift operation on the left operand by the amount specified by the right operand.</p>
      </emu-note>

      <!-- es6num="12.8.4.1" -->
      <emu-clause id="sec-signed-right-shift-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>ShiftExpression : ShiftExpression `&gt;&gt;` AdditiveExpression</emu-grammar>
        <emu-alg>
          1. Let _lref_ be the result of evaluating |ShiftExpression|.
          1. Let _lval_ be ? GetValue(_lref_).
          1. Let _rref_ be the result of evaluating |AdditiveExpression|.
          1. Let _rval_ be ? GetValue(_rref_).
          1. Let _lnum_ be ? <del>ToInt32</del><ins>ToNumeric</ins>(_lval_).
          1. Let _rnum_ be ? <del>ToUint32</del><ins>ToNumeric</ins>(_rval_).
          1. <del>Let _shiftCount_ be the result of masking out all but the least significant 5 bits of _rnum_, that is, compute _rnum_ &amp; 0x1F.</del>
          1. <del>Return the result of performing a sign-extending right shift of _lnum_ by _shiftCount_ bits. The most significant bit is propagated. The result is a signed 32-bit integer.</del>
          1. <ins>If Type(_lnum_) is different from Type(_rnum_), throw a *TypeError* exception.</ins>
          1. <ins>Let _T_ be Type(_lnum_).</ins>
          1. <ins>Return _T_::signedRightShift(_lnum_, _rnum_).</ins>
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <!-- es6num="12.8.5" -->
    <emu-clause id="sec-unsigned-right-shift-operator">
      <h1>The Unsigned Right Shift Operator ( `&gt;&gt;&gt;` )</h1>
      <emu-note>
        <p>Performs a zero-filling bitwise right shift operation on the left operand by the amount specified by the right operand.</p>
      </emu-note>

      <!-- es6num="12.8.5.1" -->
      <emu-clause id="sec-unsigned-right-shift-operator-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>
        <emu-grammar>ShiftExpression : ShiftExpression `&gt;&gt;&gt;` AdditiveExpression</emu-grammar>
        <emu-alg>
          1. Let _lref_ be the result of evaluating |ShiftExpression|.
          1. Let _lval_ be ? GetValue(_lref_).
          1. Let _rref_ be the result of evaluating |AdditiveExpression|.
          1. Let _rval_ be ? GetValue(_rref_).
          1. Let _lnum_ be ? <del>ToInt32</del><ins>ToNumeric</ins>(_lval_).
          1. Let _rnum_ be ? <del>ToUint32</del><ins>ToNumeric</ins>(_rval_).
          1. <del>Let _shiftCount_ be the result of masking out all but the least significant 5 bits of _rnum_, that is, compute _rnum_ &amp; 0x1F.</del>
          1. <del>Return the result of performing a zero-filling right shift of _lnum_ by _shiftCount_ bits. Vacated bits are filled with zero. The result is an unsigned 32-bit integer.</del>
          1. <ins>If Type(_lnum_) is different from Type(_rnum_), throw a *TypeError* exception.</ins>
          1. <ins>Let _T_ be Type(_lnum_).</ins>
          1. <ins>Return _T_::unsignedRightShift(_lnum_, _rnum_).</ins>
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <!-- es6num="12.11" -->
  <emu-clause id="sec-binary-bitwise-operators">
    <h1>Binary Bitwise Operators</h1>

    <!-- es6num="12.11.3" -->
    <emu-clause id="sec-binary-bitwise-operators-runtime-semantics-evaluation">
      <h1>Runtime Semantics: Evaluation</h1>
      <p>The production <emu-grammar>A : A @ B</emu-grammar>, where @ is one of the bitwise operators in the productions above, is evaluated as follows:</p>
      <emu-alg>
        1. Let _lref_ be the result of evaluating _A_.
        1. Let _lval_ be ? GetValue(_lref_).
        1. Let _rref_ be the result of evaluating _B_.
        1. Let _rval_ be ? GetValue(_rref_).
        1. Let _lnum_ be ? <del>ToInt32</del><ins>ToNumeric</ins>(_lval_).
        1. Let _rnum_ be ? <del>ToUint32</del><ins>ToNumeric</ins>(_rval_).
        1. <ins>If Type(_lnum_) is different from Type(_rnum_), throw a *TypeError* exception.</ins>
        1. <ins>Let _T_ be Type(_lnum_).</ins>
        1. <ins>If @ is `&amp;`, return _T_::bitwiseAND(_lnum_, _rnum_).</ins>
        1. <ins>If @ is `|`, return _T_::bitwiseOR(_lnum_, _rnum_).</ins>
        1. <ins>Otherwise, @ is `^`; return _T_::bitwiseXOR(_lnum_, _rnum_).</ins>
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-bigint-objects">
  <h1>BigInt Objects</h1>
    <emu-clause id="sec-bigint-constructor">
      <h1>The BigInt Constructor</h1>
      <p>The BigInt constructor is the <dfn>%BigInt%</dfn> intrinsic object and the initial value of the `BigInt` property of the global object. When `BigInt` is called as a function, it performs a type conversion.</p>

      <emu-clause id="sec-is-integer" aoid="IsInteger">
        <h1>IsInteger ( _number_ )</h1>
        <emu-alg>
          1. Assert: Type(_number_) is Number.
          1. If _number_ is *NaN*, *+&infin;*, or *-&infin;*, return *false*.
          1. Let _integer_ be ! ToInteger(_number_).
          1. If ! SameValueZero(_integer_, _number_) is *false*, return *false*.
          1. Otherwise, return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-number-to-bigint" aoid="NumberToBigInt">
        <h1>NumberToBigInt ( _number_ )</h1>
        <emu-alg>
          1. Assert: Type(_number_) is Number.
          1. If IsInteger(_number_) is *false*, throw a *RangeError* exception.
          1. Return a BigInt representing the mathematical value of _number_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bigint-constructor-number-value">
        <h1>BigInt ( _value_ )</h1>
        <p>When `BigInt` is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If NewTarget is not *undefined*, throw a *TypeError* exception.
          1. Let _prim_ be ? ToPrimitive(_value_, hint Number).
          1. If Type(_prim_) is Number, return ? NumberToBigInt(_prim_).
          1. Otherwise, return ? ToBigInt(_value_).
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-bigint-constructor">
      <h1>Properties of the BigInt Constructor</h1>
      <p>The value of the [[Prototype]] internal slot of the BigInt constructor is the intrinsic object %FunctionPrototype%.</p>
      <p>The BigInt constructor has the following properties:</p>

      <!-- es6num="20.1.2.2" -->
      <emu-clause id="sec-bigint.asuintn">
        <h1>BigInt.asUintN ( _bits_, _bigint_ )</h1>
        <p>When the `BigInt.asUintN` function is called with two arguments _bits_ and _bigint_, the following steps are taken:</p>
        <emu-alg>
          1. Let _bits_ be ? ToIndex(_bits_).
          1. Let _bigint_ be ? ToBigInt(_bigint_).
          1. Return a BigInt representing _bigint_ modulo 2<sup>_bits_</sup>.
        </emu-alg>
      </emu-clause>

      <!-- es6num="20.1.2.3" -->
      <emu-clause id="sec-bigint.asintn">
        <h1>BigInt.asIntN ( _bits_, _bigint_ )</h1>
        <p>When the `BigInt.asIntN` is called with two arguments _bits_ and _bigint_, the following steps are taken:</p>
        <emu-alg>
          1. Let _bits_ be ? ToIndex(_bits_).
          1. Let _bigint_ be ? ToBigInt(_bigint_).
          1. Let _mod_ be a BigInt representing _bigint_ modulo 2<sup>_bits_</sup>.
          1. If _mod_ &ge; 2<sup>_bits_ - 1</sup>, return _mod_ - 2<sup>_bits_</sup>; otherwise, return _mod_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bigint.prototype">
        <h1>BigInt.prototype</h1>
        <p>The initial value of `BigInt.prototype` is the intrinsic object %BigIntPrototype%.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-bigint-prototype-object">
      <h1>Properties of the BigInt Prototype Object</h1>
      <p>The BigInt prototype object is the intrinsic object <dfn>%BigIntPrototype%</dfn>. The BigInt prototype object is an ordinary object. The BigInt prototype is not a BigInt object; it does not have a [[BigIntData]] internal slot.</p>
      <p>The value of the [[Prototype]] internal slot of the BigInt prototype object is the intrinsic object %ObjectPrototype%.</p>
      <p>The abstract operation thisBigIntValue(_value_) performs the following steps:</p>
      <emu-alg>
        1. If Type(_value_) is BigInt, return _value_.
        1. If Type(_value_) is Object and _value_ has a [[BigIntData]] internal slot, then
          1. Assert: Type(_value_.[[BigIntData]]) is BigInt.
          1. Return _value_.[[BigIntData]].
        1. Throw a *TypeError* exception.
      </emu-alg>
      <p>The phrase &ldquo;this BigInt value&rdquo; within the specification of a method refers to the result returned by calling the abstract operation thisBigIntValue with the *this* value of the method invocation passed as the argument.</p>

      <!-- es6num="20.1.3.1" -->
      <emu-clause id="sec-bigint.prototype.constructor">
        <h1>BigInt.prototype.constructor</h1>
        <p>The initial value of `BigInt.prototype.constructor` is the intrinsic object %BigInt%.</p>
      </emu-clause>

      <!-- es6num="20.1.3.4" -->
      <emu-clause id="sec-bigint.prototype.tolocalestring">
        <h1>BigInt.prototype.toLocaleString ( [ _reserved1_ [ , _reserved2_ ] ] )</h1>
        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the `BigInt.prototype.toLocaleString` method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of the `toLocaleString` method is used.</p>
        <p>Produces a String value that represents this BigInt value formatted according to the conventions of the host environment's current locale. This function is implementation-dependent, and it is permissible, but not encouraged, for it to return the same thing as `toString`.</p>
        <p>The meanings of the optional parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not use those parameter positions for anything else.</p>
      </emu-clause>

      <!-- es6num="20.1.3.6" -->
      <emu-clause id="sec-bigint.prototype.tostring">
        <h1>BigInt.prototype.toString ( [ _radix_ ] )</h1>
        <emu-note>
          <p>The optional _radix_ should be an integer value in the inclusive range 2 to 36. If _radix_ not present or is *undefined* the Number 10 is used as the value of _radix_.</p>
        </emu-note>
        <p>The following steps are performed:</p>
        <emu-alg>
          1. Let _x_ be ? thisBigIntValue(*this* value).
          1. If _radix_ is not present, let _radixNumber_ be 10.
          1. Else if _radix_ is *undefined*, let _radixNumber_ be 10.
          1. Else, let _radixNumber_ be ? ToInteger(_radix_).
          1. If _radixNumber_ &lt; 2 or _radixNumber_ &gt; 36, throw a *RangeError* exception.
          1. If _radixNumber_ = 10, return ! ToString(_x_).
          1. Return the String representation of this Number value using the radix specified by _radixNumber_. Letters `a`-`z` are used for digits with values 10 through 35. The precise algorithm is implementation-dependent, however the algorithm should be a generalization of that specified in <emu-xref href="#sec-tostring-applied-to-the-bigint-type"></emu-xref>.
        </emu-alg>
        <p>The `toString` function is not generic; it throws a *TypeError* exception if its *this* value is not a BigInt or a BigInt object. Therefore, it cannot be transferred to other kinds of objects for use as a method.</p>
      </emu-clause>

      <!-- es6num="20.1.3.7" -->
      <emu-clause id="sec-bigint.prototype.valueof">
        <h1>BigInt.prototype.valueOf ( )</h1>
        <emu-alg>
          1. Return ? thisBigIntValue(*this* value).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-bigint-@@tostringtag">
        <h1>BigInt.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value `"BigInt"`.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>

<emu-clause id="sec-modifications">
  <h1>Modified algorithms</h1>
      <!-- es6num="24.3.2.1" -->
      <emu-clause id="sec-serializejsonproperty" aoid="SerializeJSONProperty">
        <h1>Runtime Semantics: SerializeJSONProperty ( _key_, _holder_ )</h1>
        <p>The abstract operation SerializeJSONProperty with arguments _key_, and _holder_ has access to _ReplacerFunction_ from the invocation of the `stringify` method. Its algorithm is as follows:</p>
        <emu-alg>
          1. Let _value_ be ? Get(_holder_, _key_).
          1. If Type(_value_) is Object <ins>or BigInt</ins>, then
            1. Let _toJSON_ be ? <del>Get</del><ins>GetV</ins>(_value_, `"toJSON"`).
            1. If IsCallable(_toJSON_) is *true*, then
              1. Set _value_ to ? Call(_toJSON_, _value_, &laquo; _key_ &raquo;).
          1. If _ReplacerFunction_ is not *undefined*, then
            1. Set _value_ to ? Call(_ReplacerFunction_, _holder_, &laquo; _key_, _value_ &raquo;).
          1. If Type(_value_) is Object, then
            1. If _value_ has a [[NumberData]] internal slot, then
              1. Set _value_ to ? ToNumber(_value_).
            1. Else if _value_ has a [[StringData]] internal slot, then
              1. Set _value_ to ? ToString(_value_).
            1. Else if _value_ has a [[BooleanData]] internal slot, then
              1. Set _value_ to _value_.[[BooleanData]].
            1. <ins>Else if _value_ has a [[BigIntData]] internal slot, then</ins>
              1. <ins>Set _value_ to _value_.[[BigIntData]].</ins>
          1. If _value_ is *null*, return `"null"`.
          1. If _value_ is *true*, return `"true"`.
          1. If _value_ is *false*, return `"false"`.
          1. If Type(_value_) is String, return QuoteJSONString(_value_).
          1. If Type(_value_) is Number, then
            1. If _value_ is finite, return ! ToString(_value_).
            1. Else, return `"null"`.
          1. <ins>If Type(_value_) is BigInt, throw a *TypeError* exception.</ins>
          1. If Type(_value_) is Object and IsCallable(_value_) is *false*, then
            1. Let _isArray_ be ? IsArray(_value_).
            1. If _isArray_ is *true*, return ? SerializeJSONArray(_value_).
            1. Else, return ? SerializeJSONObject(_value_).
          1. Return *undefined*.
        </emu-alg>
      </emu-clause>

      <!-- es6num="20.1.1.1" -->
      <emu-clause id="sec-number-constructor-number-value">
        <h1>Number ( _value_ )</h1>
        <p>When `Number` is called with argument _value_, the following steps are taken:</p>
        <emu-alg>
          1. If no arguments were passed to this function invocation, let _n_ be *+0*.
          1. Else,
            1. Let _prim_ be ? ToNumeric(_value_).
            1. If Type(_prim_) is BigInt, let _n_ be the Number value for _prim_.
            1. Otherwise, let _n_ be _prim_.
          1. If NewTarget is *undefined*, return _n_.
          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, `"%NumberPrototype%"`, &laquo; [[NumberData]] &raquo;).
          1. Set _O_.[[NumberData]] to _n_.
          1. Return _O_.
        </emu-alg>
        <emu-note>See <emu-xref href="#sec-ecmascript-language-types-number-type"></emu-xref> in the second-to-last paragraph for the definition of the phrase "The Number value for _prim_".</emu-note>
        <emu-integration-plans>That paragraph should possibly be refactored into a separate abstract operation; see <a href="https://github.com/tc39/proposal-bigint/issues/10">this bug</a> for more discussion about the integration of different numeric types and casting operations between them.</emu-integration-plans>
      </emu-clause>

      <!-- es6num="20.2.2.26" -->
      <emu-clause id="sec-math.pow">
        <h1>Math.pow ( _base_, _exponent_ )</h1>
        <emu-alg>
          1. Let _base_ be ? ToNumber(_base_).
          1. Let _exponent_ be ? ToNumber(_exponent_).
          1. Return Number::exponentiate(_base_, _exponent_).
        </emu-alg>
      </emu-clause>
</emu-clause>

<emu-clause id="sec-typedarrays-and-dataview">
  <h1>TypedArrays and DataViews</h1>
  <p>BigInt is integrated into TypedArray, DataView, SharedArrayBuffer and Atomics by providing Int64 and Uint64 access as represented by BigInts on the ECMAScript side.</p>

  <emu-clause id="sec-typedarray-objects">
    <h1>TypedArray Objects</h1>
    <emu-table id="table-49" caption="The TypedArray Constructors">
      <table>
        <tbody>
        <tr>
          <th>
            Constructor Name and Intrinsic
          </th>
          <th>
            Element Type
          </th>
          <th>
            Element Size
          </th>
          <th>
            Conversion Operation
          </th>
          <th>
            Description
          </th>
          <th>
            Equivalent C Type
          </th>
        </tr>
        <tr>
          <td>
            <ins>BigInt64Array</ins>
            <br>
            <ins>%BigInt64Array%</ins>
          </td>
          <td>
            <ins>BigInt64</ins>
          </td>
          <td>
            <ins>8</ins>
          </td>
          <td>
            <ins>ToBigInt64</ins>
          </td>
          <td>
            <ins>64-bit two's complement signed integer</ins>
          </td>
          <td>
            <ins>signed long long</ins>
          </td>
        </tr>
        <tr>
          <td>
            <ins>BigUint64Array</ins>
            <br>
            <ins>%BigUint64Array%</ins>
          </td>
          <td>
            <ins>BigUint64</ins>
          </td>
          <td>
            <ins>8</ins>
          </td>
          <td>
            <ins>ToBigUint64</ins>
          </td>
          <td>
            <ins>64-bit unsigned integer</ins>
          </td>
          <td>
            <ins>unsigned long long</ins>
          </td>
        </tr>
        </tbody>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-string-to-bigint" aoid="StringToBigInt">
    <h1>StringToBigInt ( _argument_ )</h1>
          <p>Apply the algorithm in <emu-xref href="#sec-tonumber-applied-to-the-string-type"></emu-xref> with the following changes:</p>
          <ul>
            <li>Replace the |StrUnsignedDecimalLiteral| production with |DecimalDigits| to not allow *Infinity*, decimal points, or exponents.</li>
            <li>If the MV is *NaN*, return *NaN*, otherwise return the BigInt which exactly corresponds to the MV, rather than rounding to a Number.</li>
          </ul>
    <emu-note type="editor">StringToBigInt(`""`) is `0n` according to the logic in <emu-xref href="#sec-tonumber-applied-to-the-string-type"></emu-xref>.</emu-note>
  </emu-clause>

  <emu-clause id="sec-to-bigint" aoid="ToBigInt">
    <h1>ToBigInt ( _argument_ )</h1>
    <p>The abstract operation ToBigInt converts its argument _argument_ to a BigInt value, or throws if an implicit conversion from Number would be required.</p>
    <emu-alg>
      1. Let _prim_ be ? ToPrimitive(_argument_, hint Number).
      1. Return the value that _prim_ corresponds to in <emu-xref href="#table-to-bigint"></emu-xref>.
    </emu-alg>
    <emu-table id="table-to-bigint" caption="BigInt Conversions">
    <table>
      <tbody>
      <tr>
        <th>
          Argument Type
        </th>
        <th>
          Result
        </th>
      </tr>
      <tr>
        <td>
          Undefined
        </td>
        <td>
          Throw a *TypeError* exception.
        </td>
      </tr>
      <tr>
        <td>
          Null
        </td>
        <td>
          Throw a *TypeError* exception.
        </td>
      </tr>
      <tr>
        <td>
          Boolean
        </td>
        <td>
          Return `1n` if _prim_ is *true* and `0n` if _prim_ is *false*.
        </td>
      </tr>
      <tr>
        <td>
          BigInt
        </td>
        <td>
          Return _prim_.
        </td>
      </tr>
      <tr>
        <td>
          Number
        </td>
        <td>
          Throw a *TypeError* exception.
        </td>
      </tr>
      <tr>
        <td>
          String
        </td>
        <td>
          <emu-alg>
            1. Let _n_ be StringToBigInt(_prim_).
            1. If _n_ is *NaN*, throw a *SyntaxError* exception.
            1. Return _n_.
          </emu-alg>
        </td>
      </tr>
      <tr>
        <td>
          Symbol
        </td>
        <td>
          Throw a *TypeError* exception.
        </td>
      </tr>
      </tbody>
    </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-toint32" aoid="ToInt32">
    <h1>ToInt32 ( _argument_ )</h1>
    <p>The abstract operation ToInt32 converts _argument_ to one of 2<sup>32</sup> integer values in the range <emu-eqn>-2<sup>31</sup></emu-eqn> through <emu-eqn>2<sup>31</sup>-1</emu-eqn>, inclusive. This abstract operation functions as follows:</p>
    <emu-alg>
      1. Let _number_ be ? <del>ToNumber</del><ins>ToNumeric</ins>(_argument_).
      1. If _number_ is *NaN*, *+0*, *-0*, *+&infin;*, or *-&infin;*, return *+0*.
      1. Let _int_ be the mathematical value that is the same sign as _number_ and whose magnitude is floor(abs(_number_)).
      1. Let _int32bit_ be _int_ modulo 2<sup>32</sup>.
      1. If _int32bit_ &ge; 2<sup>31</sup>, return _int32bit_ - 2<sup>32</sup>; otherwise return _int32bit_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-touint32" aoid="ToUint32">
    <h1>ToUint32 ( _argument_ )</h1>
    <p>The abstract operation ToUint32 converts _argument_ to one of 2<sup>32</sup> integer values in the range 0 through <emu-eqn>2<sup>32</sup>-1</emu-eqn>, inclusive. This abstract operation functions as follows:</p>
    <emu-alg>
      1. Let _number_ be ? <del>ToNumber</del><ins>ToNumeric</ins>(_argument_).
      1. If _number_ is *NaN*, *+0*, *-0*, *+&infin;*, or *-&infin;*, return *+0*.
      1. Let _int_ be the mathematical value that is the same sign as _number_ and whose magnitude is floor(abs(_number_)).
      1. Let _int32bit_ be _int_ modulo 2<sup>32</sup>.
      1. Return _int32bit_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-toint16" aoid="ToInt16">
    <h1>ToInt16 ( _argument_ )</h1>
    <p>The abstract operation ToInt16 converts _argument_ to one of 2<sup>16</sup> integer values in the range -32768 through 32767, inclusive. This abstract operation functions as follows:</p>
    <emu-alg>
      1. Let _number_ be ? ToNumber(_argument_).
      1. If _number_ is *NaN*, *+0*, *-0*, *+&infin;*, or *-&infin;*, return *+0*.
      1. Let _int_ be the mathematical value that is the same sign as _number_ and whose magnitude is floor(abs(_number_)).
      1. Let _int16bit_ be _int_ modulo 2<sup>16</sup>.
      1. If _int16bit_ &ge; 2<sup>15</sup>, return _int16bit_ - 2<sup>16</sup>; otherwise return _int16bit_.
    </emu-alg>
  </emu-clause>

  <!-- es6num="7.1.8" -->
  <emu-clause id="sec-touint16" aoid="ToUint16">
    <h1>ToUint16 ( _argument_ )</h1>
    <p>The abstract operation ToUint16 converts _argument_ to one of 2<sup>16</sup> integer values in the range 0 through <emu-eqn>2<sup>16</sup>-1</emu-eqn>, inclusive. This abstract operation functions as follows:</p>
    <emu-alg>
      1. Let _number_ be ? ToNumber(_argument_).
      1. If _number_ is *NaN*, *+0*, *-0*, *+&infin;*, or *-&infin;*, return *+0*.
      1. Let _int_ be the mathematical value that is the same sign as _number_ and whose magnitude is floor(abs(_number_)).
      1. Let _int16bit_ be _int_ modulo 2<sup>16</sup>.
      1. Return _int16bit_.
    </emu-alg>
    <emu-note>
      <p>Given the above definition of ToUint16:</p>
      <ul>
        <li>
          The substitution of 2<sup>16</sup> for 2<sup>32</sup> in step 4 is the only difference between ToUint32 and ToUint16.
        </li>
        <li>
          ToUint16 maps *-0* to *+0*.
        </li>
      </ul>
    </emu-note>
  </emu-clause>

  <!-- es6num="7.1.9" -->
  <emu-clause id="sec-toint8" aoid="ToInt8">
    <h1>ToInt8 ( _argument_ )</h1>
    <p>The abstract operation ToInt8 converts _argument_ to one of 2<sup>8</sup> integer values in the range -128 through 127, inclusive. This abstract operation functions as follows:</p>
    <emu-alg>
      1. Let _number_ be ? ToNumber(_argument_).
      1. If _number_ is *NaN*, *+0*, *-0*, *+&infin;*, or *-&infin;*, return *+0*.
      1. Let _int_ be the mathematical value that is the same sign as _number_ and whose magnitude is floor(abs(_number_)).
      1. Let _int8bit_ be _int_ modulo 2<sup>8</sup>.
      1. If _int8bit_ &ge; 2<sup>7</sup>, return _int8bit_ - 2<sup>8</sup>; otherwise return _int8bit_.
    </emu-alg>
  </emu-clause>

  <!-- es6num="7.1.10" -->
  <emu-clause id="sec-touint8" aoid="ToUint8">
    <h1>ToUint8 ( _argument_ )</h1>
    <p>The abstract operation ToUint8 converts _argument_ to one of 2<sup>8</sup> integer values in the range 0 through 255, inclusive. This abstract operation functions as follows:</p>
    <emu-alg>
      1. Let _number_ be ? ToNumber(_argument_).
      1. If _number_ is *NaN*, *+0*, *-0*, *+&infin;*, or *-&infin;*, return *+0*.
      1. Let _int_ be the mathematical value that is the same sign as _number_ and whose magnitude is floor(abs(_number_)).
      1. Let _int8bit_ be _int_ modulo 2<sup>8</sup>.
      1. Return _int8bit_.
    </emu-alg>
  </emu-clause>

  <!-- es6num="7.1.11" -->
  <emu-clause id="sec-touint8clamp" aoid="ToUint8Clamp">
    <h1>ToUint8Clamp ( _argument_ )</h1>
    <p>The abstract operation ToUint8Clamp converts _argument_ to one of 2<sup>8</sup> integer values in the range 0 through 255, inclusive. This abstract operation functions as follows:</p>
    <emu-alg>
      1. Let _number_ be ? ToNumber(_argument_).
      1. If _number_ is *NaN*, return *+0*.
      1. If _number_ &le; 0, return *+0*.
      1. If _number_ &ge; 255, return 255.
      1. Let _f_ be floor(_number_).
      1. If _f_ + 0.5 &lt; _number_, return _f_ + 1.
      1. If _number_ &lt; _f_ + 0.5, return _f_.
      1. If _f_ is odd, return _f_ + 1.
      1. Return _f_.
    </emu-alg>
    <emu-note>
      <p>Unlike the other ECMAScript integer conversion abstract operation, ToUint8Clamp rounds rather than truncates non-integer values and does not convert *+&infin;* to 0. ToUint8Clamp does &ldquo;round half to even&rdquo; tie-breaking. This differs from `Math.round` which does &ldquo;round half up&rdquo; tie-breaking.</p>
    </emu-note>
  </emu-clause>
    
  <emu-clause id="sec-to-big-int64" aoid="ToBigInt64">
    <h1>ToBigInt64 ( _argument_ )</h1>
    <p>The abstract operation ToBigInt64 converts _argument_ to one of 2<sup>64</sup> integer values in the range -2<sup>63</sup> through 2<sup>63</sup>-1, inclusive. This abstract operation functions as follows:</p>
    <emu-alg>
      1. Let _n_ be ? ToBigInt(_argument_).
      1. Let _int64bit_ be _n_ modulo 2<sup>64</sup>.
      1. If _int64bit_ &ge; 2<sup>63</sup>, return _int64bit_ - 2<sup>64</sup>; otherwise return _int64bit_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-to-big-uint64" aoid="ToBigUint64">
    <h1>ToBigUint64 ( _argument_ )</h1>
    <p>The abstract operation ToBigUint64 converts _argument_ to one of 2<sup>64</sup> integer values in the range 0 through 2<sup>64</sup>-1, inclusive. This abstract operation functions as follows:</p>
    <emu-alg>
      1. Let _n_ be ? ToBigInt(_argument_).
      1. Let _int64bit_ be _n_ modulo 2<sup>64</sup>.
      1. Return _int64bit_.
    </emu-alg>
  </emu-clause>

      <emu-clause id="sec-rawbytestonumber" aoid="RawBytesToNumber">
        <h1>RawBytesToNumber( _type_, _rawBytes_, _isLittleEndian_ )</h1>
        <p>The abstract operation RawBytesToNumber takes three parameters, a String _type_, a List _rawBytes_, and a Boolean _isLittleEndian_. This operation performs the following steps:</p>
        <emu-alg>
          1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.
          1. If _isLittleEndian_ is *false*, reverse the order of the elements of _rawBytes_.
          1. If _type_ is `"Float32"`, then
            1. Let _value_ be the byte elements of _rawBytes_ concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2008 binary32 value.
            1. If _value_ is an IEEE 754-2008 binary32 NaN value, return the *NaN* Number value.
            1. Return the Number value that corresponds to _value_.
          1. If _type_ is `"Float64"`, then
            1. Let _value_ be the byte elements of _rawBytes_ concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2008 binary64 value.
            1. If _value_ is an IEEE 754-2008 binary64 NaN value, return the *NaN* Number value.
            1. Return the Number value that corresponds to _value_.
          1. If the first code unit of _type_ is `"U"`<ins> or _type_ is `"BigUint64Array"`</ins>, then
            1. Let _intValue_ be the byte elements of _rawBytes_ concatenated and interpreted as a bit string encoding of an unsigned little-endian binary number.
          1. Else,
            1. Let _intValue_ be the byte elements of _rawBytes_ concatenated and interpreted as a bit string encoding of a binary little-endian two's complement number of bit length _elementSize_ &times; 8.
          1. <ins>If _type_ is `"BigUint64"` or `"BigInt64"`, return the BigInt value that corresponds to _intValue_.</ins>
          1. <ins>Otherwise, </ins>return the Number value that corresponds to _intValue_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-numbertorawbytes" aoid="NumberToRawBytes">
        <h1>NumberToRawBytes( _type_, _value_, _isLittleEndian_ )</h1>
        <p>The abstract operation NumberToRawBytes takes three parameters, a String _type_, a <ins>BigInt or a </ins>Number _value_, and a Boolean _isLittleEndian_. This operation performs the following steps:</p>
        <emu-alg>
          1. If _type_ is `"Float32"`, then
            1. Set _rawBytes_ to a List containing the 4 bytes that are the result of converting _value_ to IEEE 754-2008 binary32 format using &ldquo;Round to nearest, ties to even&rdquo; rounding mode. If _isLittleEndian_ is *false*, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If _value_ is *NaN*, _rawValue_ may be set to any implementation chosen IEEE 754-2008 binary32 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.
          1. Else if _type_ is `"Float64"`, then
            1. Set _rawBytes_ to a List containing the 8 bytes that are the IEEE 754-2008 binary64 format encoding of _value_. If _isLittleEndian_ is *false*, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If _value_ is *NaN*, _rawValue_ may be set to any implementation chosen IEEE 754-2008 binary64 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.
          1. Else,
            1. Let _n_ be the Number value of the Element Size specified in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.
            1. Let _convOp_ be the abstract operation named in the Conversion Operation column in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.
            1. Let _intValue_ be _convOp_(_value_) <ins>treated as a mathematical value, whether the result is a BigInt or Number</ins>.
            1. If _intValue_ &ge; 0, then
              1. Let _rawBytes_ be a List containing the _n_-byte binary encoding of _intValue_. If _isLittleEndian_ is *false*, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.
            1. Else,
              1. Let _rawBytes_ be a List containing the _n_-byte binary two's complement encoding of _intValue_. If _isLittleEndian_ is *false*, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.
          1. Return _rawBytes_.
        </emu-alg>
      </emu-clause>

      <!-- es6num="9.4.5.9" -->
      <emu-clause id="sec-integerindexedelementset" aoid="IntegerIndexedElementSet">
        <h1>IntegerIndexedElementSet ( _O_, _index_, _value_ )</h1>
        <p>The abstract operation IntegerIndexedElementSet with arguments _O_, _index_, and _value_ performs the following steps:</p>
        <emu-alg>
          1. Assert: Type(_index_) is Number.
          1. Assert: _O_ is an Object that has [[ViewedArrayBuffer]], [[ArrayLength]], [[ByteOffset]], and [[TypedArrayName]] internal slots.
          1. Let _arrayTypeName_ be the String value of _O_.[[TypedArrayName]].
          1. Let _elementType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _arrayTypeName_.
          1. <ins>If _arrayTypeName_ is `"BigUint64Array"` or `"BigInt64Array"`, let _numValue_ be ? ToBigInt(_value_).</ins>
          1. <ins>Otherwise,</ins> let _numValue_ be ? ToNumeric(_value_).
          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].
          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
          1. If IsInteger(_index_) is *false*, return *false*.
          1. If _index_ = *-0*, return *false*.
          1. Let _length_ be _O_.[[ArrayLength]].
          1. If _index_ &lt; 0 or _index_ &ge; _length_, return *false*.
          1. Let _offset_ be _O_.[[ByteOffset]].
          1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _arrayTypeName_.
          1. Let _indexedPosition_ be (_index_ &times; _elementSize_) + _offset_.
          1. Perform SetValueInBuffer(_buffer_, _indexedPosition_, _elementType_, _numValue_, *true*, `"Unordered"`).
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <!-- es6num="24.1.1.6" -->
      <emu-clause id="sec-setvalueinbuffer" aoid="SetValueInBuffer">
        <h1>SetValueInBuffer ( _arrayBuffer_, _byteIndex_, _type_, _value_, _isTypedArray_, _order_ [ , _isLittleEndian_ ] )</h1>
        <p>The abstract operation SetValueInBuffer takes seven parameters, an ArrayBuffer or SharedArrayBuffer _arrayBuffer_, an integer _byteIndex_, a String _type_, a Number _value_, a Boolean _isTypedArray_, a String _order_, and optionally a Boolean _isLittleEndian_. This operation performs the following steps:</p>
        <emu-alg>
          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.
          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.
          1. Assert: _byteIndex_ is an integer value &ge; 0.
          1. Assert: Type(_value_) is <ins>BigInt if _type_ is `"BigInt64"` or `"BigUint64"`; otherwise, Type(_value_) is Number or BigInt</ins>.
          1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].
          1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.
          1. If _isLittleEndian_ is not present, set _isLittleEndian_ to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
          1. Let _rawBytes_ be NumberToRawBytes(_type_, _value_, _isLittleEndian_).
          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, then
            1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
            1. Let _eventList_ be the [[EventList]] field of the element in _execution_.[[EventLists]] whose [[AgentSignifier]] is AgentSignifier().
            1. If _isTypedArray_ is *true* and _type_ is `"Int8"`, `"Uint8"`, `"Int16"`, `"Uint16"`, `"Int32"`, or `"Uint32"`, <ins>or if _type_ is `"BigInt64"` or `"BigUint64"` and _order_ is not `"Init"` or `"Unordered"`</ins>, let _noTear_ be *true*; otherwise let _noTear_ be *false*.
            1. Append WriteSharedMemory{ [[Order]]: _order_, [[NoTear]]: _noTear_, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_, [[Payload]]: _rawBytes_ } to _eventList_.
          1. Else, store the individual bytes of _rawBytes_ into _block_, in order, starting at _block_[_byteIndex_].
          1. Return NormalCompletion(*undefined*).
        </emu-alg>
        <emu-note type=editor>BigInt64 and BigUint64, like Float64, are excluded from the list of types which experience noTear writes. That is, non-atomic writes may be observed in a partially completed state.</emu-note>
      </emu-clause>

      <!-- es6num="24.1.1.5" -->
      <emu-clause id="sec-getvaluefrombuffer" aoid="GetValueFromBuffer">
        <h1>GetValueFromBuffer ( _arrayBuffer_, _byteIndex_, _type_, _isTypedArray_, _order_ [ , _isLittleEndian_ ] )</h1>
        <p>The abstract operation GetValueFromBuffer takes six parameters, an ArrayBuffer or SharedArrayBuffer _arrayBuffer_, an integer _byteIndex_, a String _type_, a Boolean _isTypedArray_, a String _order_, and optionally a Boolean _isLittleEndian_. This operation performs the following steps:</p>
        <emu-alg>
          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.
          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.
          1. Assert: _byteIndex_ is an integer value &ge; 0.
          1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].
          1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.
          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, then
            1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
            1. Let _eventList_ be the [[EventList]] field of the element in _execution_.[[EventLists]] whose [[AgentSignifier]] is AgentSignifier().
            1. If _isTypedArray_ is *true* and _type_ is `"Int8"`, `"Uint8"`, `"Int16"`, `"Uint16"`, `"Int32"`, or `"Uint32"` <ins>or if _type_ is `"BigInt64"` or `"BigUint64"` and _order_ is not `"Init"` or `"Unordered"`</ins>, let _noTear_ be *true*; otherwise let _noTear_ be *false*.
            1. Let _rawValue_ be a List of length _elementSize_ of nondeterministically chosen byte values.
            1. NOTE: In implementations, _rawValue_ is the result of a non-atomic or atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
            1. Let _readEvent_ be ReadSharedMemory{ [[Order]]: _order_, [[NoTear]]: _noTear_, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_ }.
            1. Append _readEvent_ to _eventList_.
            1. Append Chosen Value Record { [[Event]]: _readEvent_, [[ChosenValue]]: _rawValue_ } to _execution_.[[ChosenValues]].
          1. Else, let _rawValue_ be a List of _elementSize_ containing, in order, the _elementSize_ sequence of bytes starting with _block_[_byteIndex_].
          1. If _isLittleEndian_ is not present, set _isLittleEndian_ to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
          1. Return RawBytesToNumber(_type_, _rawValue_, _isLittleEndian_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-getmodifysetvalueinbuffer" aoid="GetModifySetValueInBuffer">
        <h1>GetModifySetValueInBuffer( _arrayBuffer_, _byteIndex_, _type_, _value_, _op_ [ , _isLittleEndian_ ] )</h1>
        <p>The abstract operation GetModifySetValueInBuffer takes six parameters, a SharedArrayBuffer _arrayBuffer_, a nonnegative integer _byteIndex_, a String _type_, a Number _value_, a semantic function _op_, and optionally a Boolean _isLittleEndian_. This operation performs the following steps:</p>
        <emu-alg>
          1. Assert: IsSharedArrayBuffer(_arrayBuffer_) is *true*.
          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.
          1. Assert: _byteIndex_ is an integer value &ge; 0.
          1. Assert: Type(_value_) is <ins>BigInt if _type_ is `"BigInt64"` or `"BigUint64"`; otherwise, Type(_value_) is Number</ins>.
          1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].
          1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.
          1. If _isLittleEndian_ is not present, set _isLittleEndian_ to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
          1. Let _rawBytes_ be NumberToRawBytes(_type_, _value_, _isLittleEndian_).
          1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
          1. Let _eventList_ be the [[EventList]] field of the element in _execution_.[[EventLists]] whose [[AgentSignifier]] is AgentSignifier().
          1. Let _rawBytesRead_ be a List of length _elementSize_ of nondeterministically chosen byte values.
          1. NOTE: In implementations, _rawBytesRead_ is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
          1. Let _rmwEvent_ be ReadModifyWriteSharedMemory{ [[Order]]: `"SeqCst"`, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_, [[Payload]]: _rawBytes_, [[ModifyOp]]: _op_ }.
          1. Append _rmwEvent_ to _eventList_.
          1. Append Chosen Value Record { [[Event]]: _rmwEvent_, [[ChosenValue]]: _rawBytesRead_ } to _execution_.[[ChosenValues]].
          1. Return RawBytesToNumber(_type_, _rawBytesRead_, _isLittleEndian_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-validatesharedintegertypedarray" aoid="ValidateSharedIntegerTypedArray">
        <h1>ValidateSharedIntegerTypedArray(_typedArray_ [ , _waitable_ ] )</h1>
        <p>The abstract operation ValidateSharedIntegerTypedArray takes one argument _typedArray_ and an optional Boolean _waitable_. It performs the following steps:</p>
        <emu-alg>
          1. If _waitable_ is not present, set _waitable_ to *false*.
          1. If Type(_typedArray_) is not Object, throw a *TypeError* exception.
          1. If _typedArray_ does not have a [[TypedArrayName]] internal slot, throw a *TypeError* exception.
          1. Let _typeName_ be _typedArray_.[[TypedArrayName]].
          1. If _waitable_ is *true*, then
            1. If _typeName_ is not `"Int32Array"` <ins>or `"BigInt64Array"`</ins>, throw a *TypeError* exception.
          1. Else,
            1. If _typeName_ is not `"Int8Array"`, `"Uint8Array"`, `"Int16Array"`, `"Uint16Array"`, `"Int32Array"`, `"Uint32Array"`, <ins>`"BigUint64Array"`, or `"BigInt64Array"`,</ins> throw a *TypeError* exception.
          1. Assert: _typedArray_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].
          1. If IsSharedArrayBuffer(_buffer_) is *false*, throw a *TypeError* exception.
          1. Return _buffer_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-atomicreadmodifywrite" aoid="AtomicReadModifyWrite">
        <h1>AtomicReadModifyWrite( _typedArray_, _index_, _value_, _op_ )</h1>
        <p>The abstract operation AtomicReadModifyWrite takes four arguments, _typedArray_, _index_, _value_, and a pure combining operation _op_. The pure combining operation _op_ takes two List of byte values arguments and returns a List of byte values. The operation atomically loads a value, combines it with another value, and stores the result of the combination. It returns the loaded value. It performs the following steps:</p>
        <emu-alg>
          1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_).
          1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
          1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
          1. <ins>If _arrayTypeName_ is `"BigUint64Array"` or `"BigInt64Array"`, let _v_ be ? ToBigInt(_v_).</ins>
          1. <ins>Otherwise,</ins> let _v_ be ? ToInteger(_value_).
          1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _arrayTypeName_.
          1. Let _elementType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _arrayTypeName_.
          1. Let _offset_ be _typedArray_.[[ByteOffset]].
          1. Let _indexedPosition_ be (_i_ &times; _elementSize_) + _offset_.
          1. Return GetModifySetValueInBuffer(_buffer_, _indexedPosition_, _elementType_, _v_, _op_).
        </emu-alg>
      </emu-clause>

    <emu-clause id="sec-atomics.islockfree">
      <h1>Atomics.isLockFree( _size_ )</h1>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Let _n_ be ? ToInteger(_size_).
        1. Let _AR_ be the Agent Record of the surrounding agent.
        1. If _n_ equals 1, return _AR_.[[IsLockFree1]].
        1. If _n_ equals 2, return _AR_.[[IsLockFree2]].
        1. If _n_ equals 4, return *true*.
        1. If _n_ equals 8, return _AR_.[[IsLockFree8]].
        1. Return *false*.
      </emu-alg>
      <emu-note>
        <p>`Atomics.isLockFree`() is an optimization primitive. The intuition is that if the atomic step of an atomic primitive (`compareExchange`, `load`, `store`, `add`, `sub`, `and`, `or`, `xor`, or `exchange`) on a datum of size _n_ bytes will be performed without the calling agent acquiring a lock outside the _n_ bytes comprising the datum, then `Atomics.isLockFree`(_n_) will return *true*. High-performance algorithms will use Atomics.isLockFree to determine whether to use locks or atomic operations in critical sections. If an atomic primitive is not lock-free then it is often more efficient for an algorithm to provide its own locking.</p>
        <p>`Atomics.isLockFree`(4) always returns *true* as that can be supported on all known relevant hardware. Being able to assume this will generally simplify programs.</p>
        <p>Regardless of the value of `Atomics.isLockFree`, all atomic operations are guaranteed to be atomic. For example, they will never have a visible operation take place in the middle of the operation (e.g., "tearing").</p>
      </emu-note>
    </emu-clause

    <emu-clause id="sec-atomics.wait">
      <h1>Atomics.wait( _typedArray_, _index_, _value_, _timeout_ )</h1>
      <p>`Atomics.wait` puts the calling agent in a wait queue and puts it to sleep until it is awoken or the sleep times out. The following steps are taken:</p>
      <emu-alg>
        1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_, *true*).
        1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
        1. <ins>If _typedArray_.[[TypedArrayName]] is `"BigInt64Array"`, let _v_ be ? ToBigInt64(_value_).</ins>
        1. <ins>Otherwise,</ins> let _v_ be ? ToInt32(_value_).
        1. Let _q_ be ? ToNumber(_timeout_).
        1. If _q_ is *NaN*, let _t_ be *+&infin;*, else let _t_ be max(_q_, 0).
        1. Let _B_ be AgentCanSuspend().
        1. If _B_ is *false*, throw a *TypeError* exception.
        1. Let _block_ be _buffer_.[[ArrayBufferData]].
        1. Let _offset_ be _typedArray_.[[ByteOffset]].
        1. <ins>Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _arrayTypeName_.</ins>
        1. Let _indexedPosition_ be (_i_ &times; <del>4</del><ins>_elementSize_</ins>) + _offset_.
        1. Let _WL_ be GetWaiterList(_block_, _indexedPosition_).
        1. Perform EnterCriticalSection(_WL_).
        1. Let _w_ be ! AtomicLoad(_typedArray_, _i_).
        1. If _v_ is not equal to _w_, then
          1. Perform LeaveCriticalSection(_WL_).
          1. Return the String `"not-equal"`.
        1. Let _W_ be AgentSignifier().
        1. Perform AddWaiter(_WL_, _W_).
        1. Let _awoken_ be Suspend(_WL_, _W_, _t_).
        1. If _awoken_ is *true*, then
          1. Assert: _W_ is not on the list of waiters in _WL_.
        1. Else,
          1. Perform RemoveWaiter(_WL_, _W_).
        1. Perform LeaveCriticalSection(_WL_).
        1. If _awoken_ is *true*, return the String `"ok"`.
        1. Return the String `"timed-out"`.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.wake">
      <h1>Atomics.wake( _typedArray_, _index_, _count_ )</h1>
      <p>`Atomics.wake` wakes up some agents that are sleeping in the wait queue.  The following steps are taken:</p>
      <emu-alg>
        1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_, *true*).
        1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
        1. If _count_ is *undefined*, let _c_ be *+&infin;*.
        1. Else,
          1. Let _intCount_ be ? ToInteger(_count_).
          1. Let _c_ be max(_intCount_, 0).
        1. Let _block_ be _buffer_.[[ArrayBufferData]].
        1. Let _offset_ be _typedArray_.[[ByteOffset]].
        1. <ins>Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _arrayTypeName_.</ins>
        1. Let _indexedPosition_ be (_i_ &times; <del>4</del><ins>_elementSize_</ins>) + _offset_.
        1. Let _WL_ be GetWaiterList(_block_, _indexedPosition_).
        1. Let _n_ be 0.
        1. Perform EnterCriticalSection(_WL_).
        1. Let _S_ be RemoveWaiters(_WL_, _c_).
        1. Repeat, while _S_ is not an empty List,
          1. Let _W_ be the first agent in _S_.
          1. Remove _W_ from the front of _S_.
          1. Perform WakeWaiter(_WL_, _W_).
          1. Add 1 to _n_.
        1. Perform LeaveCriticalSection(_WL_).
        1. Return _n_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.store">
      <h1>Atomics.store( _typedArray_, _index_, _value_ )</h1>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_).
        1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
        1. <ins>If _arrayTypeName_ is `"BigUint64Array"` or `"BigInt64Array"`, let _v_ be ? ToBigInt(_value_).</ins>
        1. <ins>Otherwise,</ins> let _v_ be ? ToInteger(_value_).
        1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
        1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _arrayTypeName_.
        1. Let _elementType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _arrayTypeName_.
        1. Let _offset_ be _typedArray_.[[ByteOffset]].
        1. Let _indexedPosition_ be (_i_ &times; _elementSize_) + _offset_.
        1. Perform SetValueInBuffer(_buffer_, _indexedPosition_, _elementType_, _v_, *true*, `"SeqCst"`).
        1. Return _v_.
      </emu-alg>
    </emu-clause>

      <!-- es6num="22.2.3.25" -->
      <emu-clause id="sec-%typedarray%.prototype.sort">
        <h1>%TypedArray%.prototype.sort ( _comparefn_ )</h1>
        <p>%TypedArray%`.prototype.sort` is a distinct function that, except as described below, implements the same requirements as those of `Array.prototype.sort` as defined in <emu-xref href="#sec-array.prototype.sort"></emu-xref>. The implementation of the %TypedArray%`.prototype.sort` specification may be optimized with the knowledge that the *this* value is an object that has a fixed length and whose integer indexed properties are not sparse. The only internal methods of the *this* object that the algorithm may call are [[Get]] and [[Set]].</p>
        <p>This function is not generic. The *this* value must be an object with a [[TypedArrayName]] internal slot.</p>
        <p>Upon entry, the following steps are performed to initialize evaluation of the `sort` function. These steps are used instead of the entry steps in <emu-xref href="#sec-array.prototype.sort"></emu-xref>:</p>
        <emu-alg>
          1. If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.
          1. Let _obj_ be the *this* value.
          1. Let _buffer_ be ? ValidateTypedArray(_obj_).
          1. Let _len_ be _obj_.[[ArrayLength]].
        </emu-alg>
        <p>The implementation-defined sort order condition for exotic objects is not applied by %TypedArray%`.prototype.sort`.</p>
        <p>The following version of SortCompare is used by %TypedArray%`.prototype.sort`. It performs a numeric comparison rather than the string comparison used in <emu-xref href="#sec-array.prototype.sort"></emu-xref>. SortCompare has access to the _comparefn_ and _buffer_ values of the current invocation of the `sort` method.</p>
        <p>When the TypedArray SortCompare abstract operation is called with two arguments _x_ and _y_, the following steps are taken:</p>
        <emu-alg>
          1. Assert: Both Type(_x_) and Type(_y_) is Number <ins>or both are BigInt</ins>.
          1. If _comparefn_ is not *undefined*, then
            1. Let _v_ be ? ToNumber(? Call(_comparefn_, *undefined*, &laquo; _x_, _y_ &raquo;)).
            1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
            1. If _v_ is *NaN*, return *+0*.
            1. Return _v_.
          1. If _x_ and _y_ are both *NaN*, return *+0*.
          1. If _x_ is *NaN*, return 1.
          1. If _y_ is *NaN*, return -1.
          1. If _x_ &lt; _y_, return -1.
          1. If _x_ &gt; _y_, return 1.
          1. If _x_ is *-0* and _y_ is *+0*, return -1.
          1. If _x_ is *+0* and _y_ is *-0*, return 1.
          1. Return *+0*.
        </emu-alg>
        <emu-note>
          <p>Because *NaN* always compares greater than any other value, *NaN* property values always sort to the end of the result when _comparefn_ is not provided.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="typedarray-species-create" aoid="TypedArraySpeciesCreate">
        <h1>TypedArraySpeciesCreate ( _exemplar_, _argumentList_ )</h1>
        <p>The abstract operation TypedArraySpeciesCreate with arguments _exemplar_ and _argumentList_ is used to specify the creation of a new TypedArray object using a constructor function that is derived from _exemplar_. It performs the following steps:</p>
        <emu-alg>
          1. Assert: _exemplar_ is an Object that has a [[TypedArrayName]] internal slot.
          1. Let _defaultConstructor_ be the intrinsic object listed in column one of <emu-xref href="#table-49"></emu-xref> for _exemplar_.[[TypedArrayName]].
          1. Let _constructor_ be ? SpeciesConstructor(_exemplar_, _defaultConstructor_).
          1. <del>Return</del><ins>Let _result_ be</ins> ? TypedArrayCreate(_constructor_, _argumentList_).
          1. <ins>Assert: _result_ has a [[TypedArrayName]] internal slot.</ins>
          1. <ins>If _result_.[[TypedArrayName]] contains the substring `"Big"` and _exemplar_.[[TypedArrayName]] does not contain the substring `"Big"`, or vice versa, throw a *TypeError* exception.</ins>
          1. <ins>Return _result_.</ins>
        </emu-alg>
      </emu-clause>

      <!-- es6num="22.2.3.8" -->
      <emu-clause id="sec-%typedarray%.prototype.fill">
        <h1>%TypedArray%.prototype.fill ( _value_ [ , _start_ [ , _end_ ] ] )</h1>
        <p>The interpretation and use of the arguments of %TypedArray%`.prototype.fill` are the same as for `Array.prototype.fill` as defined in <emu-xref href="#sec-array.prototype.fill"></emu-xref>.</p>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. Perform ? ValidateTypedArray(_O_).
          1. Let _len_ be _O_.[[ArrayLength]].
          1. <ins>If _O_.[[TypedArrayName]] is `"BigUint64Array"` or `"BigInt64Array"`, let _value_ be ? ToBigInt(_value_).</ins>
          1. <ins>Otherwise,</ins> let _value_ be ? ToNumber(_value_).
          1. Let _relativeStart_ be ? ToInteger(_start_).
          1. If _relativeStart_ &lt; 0, let _k_ be max((_len_ + _relativeStart_), 0); else let _k_ be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToInteger(_end_).
          1. If _relativeEnd_ &lt; 0, let _final_ be max((_len_ + _relativeEnd_), 0); else let _final_ be min(_relativeEnd_, _len_).
          1. If IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) is *true*, throw a *TypeError* exception.
          1. Repeat, while _k_ &lt; _final_
            1. Let _Pk_ be ! ToString(_k_).
            1. Perform ! Set(_O_, _Pk_, _value_, *true*).
            1. Increase _k_ by 1.
          1. Return _O_.
        </emu-alg>
      </emu-clause>

        <!-- es6num="22.2.3.22.1" -->
        <emu-clause id="sec-%typedarray%.prototype.set-array-offset">
          <h1>%TypedArray%.prototype.set ( _array_ [ , _offset_ ] )</h1>
          <p>Sets multiple values in this _TypedArray_, reading the values from the object _array_. The optional _offset_ value indicates the first element index in this _TypedArray_ where values are written. If omitted, it is assumed to be 0.</p>
          <emu-alg>
            1. Assert: _array_ is any ECMAScript language value other than an Object with a [[TypedArrayName]] internal slot. If it is such an Object, the definition in <emu-xref href="#sec-%typedarray%.prototype.set-typedarray-offset"></emu-xref> applies.
            1. Let _target_ be the *this* value.
            1. If Type(_target_) is not Object, throw a *TypeError* exception.
            1. If _target_ does not have a [[TypedArrayName]] internal slot, throw a *TypeError* exception.
            1. Assert: _target_ has a [[ViewedArrayBuffer]] internal slot.
            1. Let _targetOffset_ be ? ToInteger(_offset_).
            1. If _targetOffset_ &lt; 0, throw a *RangeError* exception.
            1. Let _targetBuffer_ be _target_.[[ViewedArrayBuffer]].
            1. If IsDetachedBuffer(_targetBuffer_) is *true*, throw a *TypeError* exception.
            1. Let _targetLength_ be _target_.[[ArrayLength]].
            1. Let _targetName_ be the String value of _target_.[[TypedArrayName]].
            1. Let _targetElementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _targetName_.
            1. Let _targetType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _targetName_.
            1. Let _targetByteOffset_ be _target_.[[ByteOffset]].
            1. Let _src_ be ? ToObject(_array_).
            1. Let _srcLength_ be ? ToLength(? Get(_src_, `"length"`)).
            1. If _srcLength_ + _targetOffset_ &gt; _targetLength_, throw a *RangeError* exception.
            1. Let _targetByteIndex_ be _targetOffset_ &times; _targetElementSize_ + _targetByteOffset_.
            1. Let _k_ be 0.
            1. Let _limit_ be _targetByteIndex_ + _targetElementSize_ &times; _srcLength_.
            1. Repeat, while _targetByteIndex_ &lt; _limit_
              1. Let _Pk_ be ! ToString(_k_).
              1. <del>Let _kNumber_ be ? ToNumber(? Get(_src_, _Pk_)).</del>
              1. <ins>Let _value_ be ? Get(_src_, _Pk_).</ins>
              1. <ins>If _target_.[[TypedArrayName]] is `"BigUint64Array"` or `"BigInt64Array"`, let _value_ be ? ToBigInt(_value_).</ins>
              1. <ins>Otherwise, let _value_ be ? ToNumber(_value_).</ins>
              1. If IsDetachedBuffer(_targetBuffer_) is *true*, throw a *TypeError* exception.
              1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, _targetType_, <del>_kNumber_</del><ins>_value_</ins>, *true*, `"Unordered"`).
              1. Set _k_ to _k_ + 1.
              1. Set _targetByteIndex_ to _targetByteIndex_ + _targetElementSize_.
            1. Return *undefined*.
          </emu-alg>
        </emu-clause>

        <!-- es6num="22.2.3.22.2" -->
        <emu-clause id="sec-%typedarray%.prototype.set-typedarray-offset">
          <h1>%TypedArray%.prototype.set( _typedArray_ [ , _offset_ ] )</h1>
          <p>Sets multiple values in this _TypedArray_, reading the values from the _typedArray_ argument object. The optional _offset_ value indicates the first element index in this _TypedArray_ where values are written. If omitted, it is assumed to be 0.</p>
          <emu-alg>
            1. Assert: _typedArray_ has a [[TypedArrayName]] internal slot. If it does not, the definition in <emu-xref href="#sec-%typedarray%.prototype.set-array-offset"></emu-xref> applies.
            1. Let _target_ be the *this* value.
            1. If Type(_target_) is not Object, throw a *TypeError* exception.
            1. If _target_ does not have a [[TypedArrayName]] internal slot, throw a *TypeError* exception.
            1. Assert: _target_ has a [[ViewedArrayBuffer]] internal slot.
            1. Let _targetOffset_ be ? ToInteger(_offset_).
            1. If _targetOffset_ &lt; 0, throw a *RangeError* exception.
            1. Let _targetBuffer_ be _target_.[[ViewedArrayBuffer]].
            1. If IsDetachedBuffer(_targetBuffer_) is *true*, throw a *TypeError* exception.
            1. Let _targetLength_ be _target_.[[ArrayLength]].
            1. Let _srcBuffer_ be _typedArray_.[[ViewedArrayBuffer]].
            1. If IsDetachedBuffer(_srcBuffer_) is *true*, throw a *TypeError* exception.
            1. Let _targetName_ be the String value of _target_.[[TypedArrayName]].
            1. Let _targetType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _targetName_.
            1. Let _targetElementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _targetName_.
            1. Let _targetByteOffset_ be _target_.[[ByteOffset]].
            1. Let _srcName_ be the String value of _typedArray_.[[TypedArrayName]].
            1. Let _srcType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _srcName_.
            1. Let _srcElementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _srcName_.
            1. Let _srcLength_ be _typedArray_.[[ArrayLength]].
            1. Let _srcByteOffset_ be _typedArray_.[[ByteOffset]].
            1. If _srcLength_ + _targetOffset_ &gt; _targetLength_, throw a *RangeError* exception.
            1. <ins>If one of _srcType_ and _targetType_ contains the substring `"Big"` and the other does not, throw a *TypeError* exception.</ins>
            1. If both IsSharedArrayBuffer(_srcBuffer_) and IsSharedArrayBuffer(_targetBuffer_) are *true*, then
              1. If _srcBuffer_.[[ArrayBufferData]] and _targetBuffer_.[[ArrayBufferData]] are the same Shared Data Block values, let _same_ be *true*; else let _same_ be *false*.
            1. Else, let _same_ be SameValue(_srcBuffer_, _targetBuffer_).
            1. If _same_ is *true*, then
              1. Let _srcByteLength_ be _typedArray_.[[ByteLength]].
              1. Let _srcBuffer_ be ? CloneArrayBuffer(_srcBuffer_, _srcByteOffset_, _srcByteLength_, %ArrayBuffer%).
              1. NOTE: %ArrayBuffer% is used to clone _srcBuffer_ because is it known to not have any observable side-effects.
              1. Let _srcByteIndex_ be 0.
            1. Else, let _srcByteIndex_ be _srcByteOffset_.
            1. Let _targetByteIndex_ be _targetOffset_ &times; _targetElementSize_ + _targetByteOffset_.
            1. Let _limit_ be _targetByteIndex_ + _targetElementSize_ &times; _srcLength_.
            1. If SameValue(_srcType_, _targetType_) is *true*, then
              1. NOTE: If _srcType_ and _targetType_ are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.
              1. Repeat, while _targetByteIndex_ &lt; _limit_
                1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, `"Uint8"`, *true*, `"Unordered"`).
                1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, `"Uint8"`, _value_, *true*, `"Unordered"`).
                1. Set _srcByteIndex_ to _srcByteIndex_ + 1.
                1. Set _targetByteIndex_ to _targetByteIndex_ + 1.
            1. Else,
              1. Repeat, while _targetByteIndex_ &lt; _limit_
                1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, _srcType_, *true*, `"Unordered"`).
                1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, _targetType_, _value_, *true*, `"Unordered"`).
                1. Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_.
                1. Set _targetByteIndex_ to _targetByteIndex_ + _targetElementSize_.
            1. Return *undefined*.
          </emu-alg>
        </emu-clause>

      <!-- es6num="22.2.1.3" -->
      <emu-clause id="sec-typedarray-typedarray">
        <h1>_TypedArray_ ( _typedArray_ )</h1>
        <p>This description applies only if the _TypedArray_ function is called with at least one argument and the Type of the first argument is Object and that object has a [[TypedArrayName]] internal slot.</p>
        <p>_TypedArray_ called with argument _typedArray_ performs the following steps:</p>
        <emu-alg>
          1. Assert: Type(_typedArray_) is Object and _typedArray_ has a [[TypedArrayName]] internal slot.
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _constructorName_ be the String value of the Constructor Name value specified in <emu-xref href="#table-49"></emu-xref> for this <var>TypedArray</var> constructor.
          1. Let _O_ be ? AllocateTypedArray(_constructorName_, NewTarget, <code>"%<var>TypedArray</var>Prototype%"</code>).
          1. Let _srcArray_ be _typedArray_.
          1. Let _srcData_ be _srcArray_.[[ViewedArrayBuffer]].
          1. If IsDetachedBuffer(_srcData_) is *true*, throw a *TypeError* exception.
          1. Let _elementType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _constructorName_.
          1. Let _elementLength_ be _srcArray_.[[ArrayLength]].
          1. Let _srcName_ be the String value of _srcArray_.[[TypedArrayName]].
          1. Let _srcType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _srcName_.
          1. Let _srcElementSize_ be the Element Size value in <emu-xref href="#table-49"></emu-xref> for _srcName_.
          1. Let _srcByteOffset_ be _srcArray_.[[ByteOffset]].
          1. Let _elementSize_ be the Element Size value in <emu-xref href="#table-49"></emu-xref> for _constructorName_.
          1. Let _byteLength_ be _elementSize_ &times; _elementLength_.
          1. If IsSharedArrayBuffer(_srcData_) is *false*, then
            1. Let _bufferConstructor_ be ? SpeciesConstructor(_srcData_, %ArrayBuffer%).
          1. Else,
            1. Let _bufferConstructor_ be %ArrayBuffer%.
          1. If SameValue(_elementType_, _srcType_) is *true*, then
            1. If IsDetachedBuffer(_srcData_) is *true*, throw a *TypeError* exception.
            1. Let _data_ be ? CloneArrayBuffer(_srcData_, _srcByteOffset_, _byteLength_, _bufferConstructor_).
          1. Else,
            1. Let _data_ be ? AllocateArrayBuffer(_bufferConstructor_, _byteLength_).
            1. If IsDetachedBuffer(_srcData_) is *true*, throw a *TypeError* exception.
            1. <ins>If one of _srcType_ and _elementType_ contains the substring `"Big"` and the other does not, throw a *TypeError* exception.</ins>
            1. Let _srcByteIndex_ be _srcByteOffset_.
            1. Let _targetByteIndex_ be 0.
            1. Let _count_ be _elementLength_.
            1. Repeat, while _count_ &gt; 0
              1. Let _value_ be GetValueFromBuffer(_srcData_, _srcByteIndex_, _srcType_, *true*, `"Unordered"`).
              1. Perform SetValueInBuffer(_data_, _targetByteIndex_, _elementType_, _value_, *true*, `"Unordered"`).
              1. Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_.
              1. Set _targetByteIndex_ to _targetByteIndex_ + _elementSize_.
              1. Decrement _count_ by 1.
          1. Set _O_.[[ViewedArrayBuffer]] to _data_.
          1. Set _O_.[[ByteLength]] to _byteLength_.
          1. Set _O_.[[ByteOffset]] to 0.
          1. Set _O_.[[ArrayLength]] to _elementLength_.
          1. Return _O_.
        </emu-alg>
      </emu-clause>

      <!-- es6num="24.2.1.2" -->
      <emu-clause id="sec-setviewvalue" aoid="SetViewValue">
        <h1>SetViewValue ( _view_, _requestIndex_, _isLittleEndian_, _type_, _value_ )</h1>
        <p>The abstract operation SetViewValue with arguments _view_, _requestIndex_, _isLittleEndian_, _type_, and _value_ is used by functions on DataView instances to store values into the view's buffer. It performs the following steps:</p>
        <emu-alg>
          1. If Type(_view_) is not Object, throw a *TypeError* exception.
          1. If _view_ does not have a [[DataView]] internal slot, throw a *TypeError* exception.
          1. Assert: _view_ has a [[ViewedArrayBuffer]] internal slot.
          1. Let _getIndex_ be ? ToIndex(_requestIndex_).
          1. <ins>If _arrayTypeName_ is `"BigUint64Array"` or `"BigInt64Array"`, let _v_ be ? ToBigInt(_value_).</ins>
          1. <ins>Otherwise,</ins> let _v_ be ? ToInteger(_value_).
          1. Set _isLittleEndian_ to ToBoolean(_isLittleEndian_).
          1. Let _buffer_ be _view_.[[ViewedArrayBuffer]].
          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.
          1. Let _viewOffset_ be _view_.[[ByteOffset]].
          1. Let _viewSize_ be _view_.[[ByteLength]].
          1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.
          1. If _getIndex_ + _elementSize_ &gt; _viewSize_, throw a *RangeError* exception.
          1. Let _bufferIndex_ be _getIndex_ + _viewOffset_.
          1. Return SetValueInBuffer(_buffer_, _bufferIndex_, _type_, _v_, *false*, `"Unordered"`, _isLittleEndian_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getbigint64">
        <h1>DataView.prototype.getBigInt64 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>When the `getBigInt64` method is called with argument _byteOffset_ and optional argument _littleEndian_, the following steps are taken:</p>
        <emu-alg>
          1. Let _v_ be the *this* value.
          1. If _littleEndian_ is not present, let _littleEndian_ be *undefined*.
          1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, `"Int64"`).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.getbituint64">
        <h1>DataView.prototype.getBigUint64 ( _byteOffset_ [ , _littleEndian_ ] )</h1>
        <p>When the `getBigUint64` method is called with argument _byteOffset_ and optional argument _littleEndian_, the following steps are taken:</p>
        <emu-alg>
          1. Let _v_ be the *this* value.
          1. If _littleEndian_ is not present, let _littleEndian_ be *undefined*.
          1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, `"Uint64"`).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setbigint64">
        <h1>DataView.prototype.setBigInt64 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>When the `setBigInt64` method is called with arguments _byteOffset_ and _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _v_ be the *this* value.
          1. If _littleEndian_ is not present, let _littleEndian_ be *undefined*.
          1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, `"Int64"`, _value_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-dataview.prototype.setbiguint64">
        <h1>DataView.prototype.setBigUint64 ( _byteOffset_, _value_ [ , _littleEndian_ ] )</h1>
        <p>When the `setBigUint64` method is called with arguments _byteOffset_ and _value_, the following steps are taken:</p>
        <emu-alg>
          1. Let _v_ be the *this* value.
          1. If _littleEndian_ is not present, let _littleEndian_ be *undefined*.
          1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, `"Uint64"`, _value_).
        </emu-alg>
      </emu-clause>

</emu-clause>

  <emu-clause id="sec-agents">
    <h1>Agents</h1>

    <p>An <dfn id="agent">agent</dfn> comprises a set of ECMAScript execution contexts, an execution context stack, a running execution context, a set of named job queues, an <dfn id="agent-record">Agent Record</dfn>, and an <dfn id="executing-thread">executing thread</dfn>.  Except for the executing thread, the constituents of an agent belong exclusively to that agent.</p>
    <p>An agent's executing thread executes the jobs in the agent's job queues on the agent's execution contexts independently of other agents, except that an executing thread may be used as the executing thread by multiple agents, provided none of the agents sharing the thread have an Agent Record whose [[CanBlock]] property is *true*.</p>
    <emu-note>
      <p>Some web browsers share a single executing thread across multiple unrelated tabs of a browser window, for example.</p>
    </emu-note>
    <p>While an agent's executing thread executes the jobs in the agent's job queues, the agent is the <dfn id="surrounding-agent">surrounding agent</dfn> for the code in those jobs.  The code uses the surrounding agent to access the specification level execution objects held within the agent: the running execution context, the execution context stack, the named job queues, and the Agent Record's fields.</p>
    <emu-table id="table-agent-record" caption="Agent Record Fields">
      <table>
        <tbody>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>[[LittleEndian]]</td>
            <td>Boolean</td>
            <td>The default value computed for the <em>isLittleEndian</em> parameter when it is needed by the algorithms GetValueFromBuffer and SetValueInBuffer. The choice is implementation-dependent and should be the alternative that is most efficient for the implementation.  Once the value has been observed it cannot change.</td>
          </tr>
          <tr>
            <td>[[CanBlock]]</td>
            <td>Boolean</td>
            <td>Determines whether the agent can block or not.</td>
          </tr>
          <tr>
            <td>[[Signifier]]</td>
            <td>Any globally-unique value</td>
            <td>Uniquely identifies the agent within its agent cluster.</td>
          </tr>
          <tr>
            <td>[[IsLockFree1]]</td>
            <td>Boolean</td>
            <td>*true* if atomic operations on one-byte values are lock-free, *false* otherwise.</td>
          </tr>
          <tr>
            <td>[[IsLockFree2]]</td>
            <td>Boolean</td>
            <td>*true* if atomic operations on two-byte values are lock-free, *false* otherwise.</td>
          </tr>
          <tr>
            <td><ins>[[IsLockFree8]]</ins></td>
            <td><ins>Boolean</ins></td>
            <td><ins>*true* if atomic operations on eight-byte values are lock-free, *false* otherwise.</ins></td>
          </tr>
          <tr>
            <td>[[CandidateExecution]]</td>
            <td>A candidate execution Record</td>
            <td>See the memory model.</td>
          </tr>
        </tbody>
      </table>
    </emu-table>

    <p>Once the values of [[Signifier]], [[IsLockFree1]], [[IsLockFree8]], <ins>and [[IsLockFree8]]</ins> have been observed by any agent in the agent cluster they cannot change.</p>

    <emu-note>
      <p>The values of [[IsLockFree1]], [[IsLockFree2]], <ins>and [[IsLockFree8]]</ins> are not necessarily determined by the hardware, but may also reflect implementation choices that can vary over time and between ECMAScript implementations.</p>

      <p>There is no [[IsLockFree4]] property: 4-byte atomic operations are always lock-free.</p>

      <p>In practice, if an atomic operation is implemented with any type of lock the operation is not lock-free.  Lock-free does not imply wait-free: there is no upper bound on how many machine steps may be required to complete a lock-free atomic operation.</p>

      <p>That an atomic access of size <em>n</em> is lock-free does not imply anything about the (perceived) atomicity of non-atomic accesses of size <em>n</em>, specifically, non-atomic accesses may still be performed as a sequence of several separate memory accesses.  See ReadSharedMemory and WriteSharedMemory for details.</p>
    </emu-note>
  </emu-clause>
